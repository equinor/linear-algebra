[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/const.js",
    "content": "/**\n * Constant for converting radians to degrees\n */\nexport const RAD2DEG = 180 / Math.PI;\n/**\n * Constant for converting degrees to radians\n */\nexport const DEG2RAD = Math.PI / 180;\n/**\n * PI\n */\nexport const PI = Math.PI;\n/**\n * Two times PI\n */\nexport const TAU = 2 * Math.PI;\n/**\n * Semi PI\n */\nexport const SPI = Math.PI / 2;\n/**\n * Quarter PI\n */\nexport const QPI = Math.PI / 4;\n\n/**\n * Epsilon\n */\nexport const EPSILON = Number.EPSILON;\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/src/const.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "RAD2DEG",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~RAD2DEG",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{RAD2DEG}",
    "description": "Constant for converting radians to degrees",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "DEG2RAD",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~DEG2RAD",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{DEG2RAD}",
    "description": "Constant for converting degrees to radians",
    "lineNumber": 8,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "variable",
    "name": "PI",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~PI",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{PI}",
    "description": "PI",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "name": "TAU",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~TAU",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{TAU}",
    "description": "Two times PI",
    "lineNumber": 16,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "name": "SPI",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~SPI",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{SPI}",
    "description": "Semi PI",
    "lineNumber": 20,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "name": "QPI",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~QPI",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{QPI}",
    "description": "Quarter PI",
    "lineNumber": 24,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "name": "EPSILON",
    "memberof": "src/const.js",
    "static": true,
    "longname": "src/const.js~EPSILON",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/const.js",
    "importStyle": "{EPSILON}",
    "description": "Epsilon",
    "lineNumber": 29,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/functions.js",
    "content": "import { RAD2DEG, DEG2RAD, TAU } from './const';\n\n/**\n * Component-wise addition of two arrays/vectors.\n * If target is NOT specified, the first argument will\n * be mutated. Target will be overwritten and NOT included in the sum.\n * @param {number[]} to left operand\n * @param {number[]} from right operand\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} array/vector\n */\nexport function add(to, from, target = null) {\n  if (target) {\n    if (target.length === 0) target.length = to.length;\n  } else {\n    target = to;\n  }\n  for (let i = 0; i < target.length; i++) {\n    target[i] = to[i] + from[i];\n  }\n  return target;\n}\n\n/**\n * Component-wise addition of one vector with a scaled version of another vector.\n * If target is NOT specified, the first argument will\n * be mutated. Target will be overwritten and NOT included in the sum.\n * @param {number[]} to left operand\n * @param {number[]} from right operand\n * @param {number} factor scaling factor to apply to from-vector\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} array/vector\n */\nexport function addScaled(to, from, factor, target = null) {\n  if (target) {\n    if (target.length === 0) target.length = to.length;\n  } else {\n    target = to;\n  }\n  for (let i = 0; i < target.length; i++) {\n    target[i] = to[i] + from[i] * factor;\n  }\n  return target;\n}\n\n/**\n * Component-wise addition of a set of arrays/vectors.\n * If target is NOT specified, the first element in the set will\n * be mutated. Target (if it has valid values) WILL be included in the sum.\n * @param {number[][]} vectors Array of equally length arrays/vectors (to be added)\n * @param {number[]} target optional array/vector to add into\n * @return {number[]} array/vector\n */\nexport function addAll(vectors, target = null) {\n  let start = 0;\n  if (!target) {\n    target = vectors[0];\n    start++;\n  }\n\n  for (let i = start; i < vectors.length; i++) {\n    for (let j = 0; j < vectors[i].length; j++) {\n      if (i === 0 && !Number.isFinite(target[j])) {\n        target[j] = vectors[i][j];\n      } else {\n        target[j] += vectors[i][j];\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Component-wise subtraction of two arrays/vectors.\n * If target is NOT specified, the first argument will\n * be mutated. Target will be overwritten and NOT included in the sum.\n * @param {number[]} from left operand\n * @param {number[]} vector right operand\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} array/vector\n */\nexport function sub(from, vector, target = null) {\n  if (target) {\n    if (target.length === 0) target.length = from.length;\n  } else {\n    target = from;\n  }\n  for (let i = 0; i < target.length; i++) {\n    target[i] = from[i] - vector[i];\n  }\n  return target;\n}\n\n/**\n * Component-wise addition of one vector with a scaled version of another vector.\n * If target is NOT specified, the first argument will\n * be mutated. Target will be overwritten and NOT included in the sum.\n * @param {number[]} from left operand\n * @param {number[]} vector right operand\n * @param {number} factor scaling factor to apply to vector that will be subtracted\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} array/vector\n */\nexport function subScaled(from, vector, factor, target = null) {\n  if (target) {\n    if (target.length === 0) target.length = from.length;\n  } else {\n    target = from;\n  }\n  for (let i = 0; i < target.length; i++) {\n    target[i] = from[i] - vector[i] * factor;\n  }\n  return target;\n}\n\n/**\n * Component-wise subtraction of array/vector and all elements in vectors.\n * If target is NOT specified, the first argument will\n * be mutated. Target will be overwritten and NOT included in the sum.\n * @param {number[]} from left operand\n * @param {number[][]} vectors right operand\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} array/vector\n */\nexport function subAll(from, vectors, target = null) {\n  if (target) {\n    if (target.length === 0) target.length = from.length;\n  } else {\n    target = from;\n  }\n\n  for (let i = 0; i < vectors.length; i++) {\n    for (let j = 0; j < vectors[i].length; j++) {\n      if (i === 0) {\n        target[j] = from[j] - vectors[i][j];\n      } else {\n        target[j] -= vectors[i][j];\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Create a vector from two points. This function will NOT mutate any\n * arguments unless 'target' is the same as 'from'.\n * @param {number[]} from start coordinates\n * @param {number[]} to end coordinates\n * @param {number[]} target optional array/vector to store the resulting vector\n * @return {number[]} vector\n */\nexport function vec(from, to, target = null) {\n  if (!target) {\n    target = to.slice();\n  } else {\n    if (target.length === 0) {\n      target.length = to.length;\n    }\n    for (let i = 0; i < target.length; i++) {\n      target[i] = to[i];\n    }\n  }\n  return sub(target, from);\n}\n\n/**\n * Component-wise scaling of an array or vector\n * @param {number[]} arr array/vector to scale\n * @param {number} factor scaling factor\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} scaled array/vector\n */\nexport function scale(arr, factor, target = null) {\n  target = target || arr;\n  for (let i = 0; i < arr.length; i++) {\n    target[i] = arr[i] * factor;\n  }\n  return target;\n}\n\n/**\n * Computes the sum of squares\n * @param {number[]} arr array/vector to compute\n * @return {number}\n */\nexport function sumsqr(arr) {\n  return arr.reduce((sum, v) => sum + v ** 2, 0);\n}\n\n/**\n * Computes the scalar value (length) of a vector\n * @param {number[]} vector array/vector to compute\n * @return {number}\n */\nexport function scalar(vector) {\n  const sq = sumsqr(vector);\n  if (sq === 0) return sq;\n  return Math.sqrt(sq);\n}\n\n/**\n * Normalizes an array/vector\n * @param {number[]} vector array/vector to notmalize\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} normalized array/vector\n */\nexport function norm(vector, target = null) {\n  target = target || vector;\n  const sc = scalar(vector);\n  const f = sc === 0 ? 0 : 1 / sc;\n  return scale(vector, f, target);\n}\n\n/**\n * Describes relationships between two points.\n * @param {number[]} from start coordinates\n * @param {number[]} to end coordinates\n * @param {number[]} target optional array/vector to store the result\n * @return {{vector: number[], sqr: number, distance: number, unit: number[]}}\n */\nexport function descr(from, to, target = null) {\n  if (!target) {\n    target = to.slice();\n  } else {\n    if (target.length === 0) {\n      target.length = to.length;\n    }\n    for (let i = 0; i < target.length; i++) {\n      target[i] = to[i];\n    }\n  }\n  const vector = sub(target, from);\n  const sqr = sumsqr(vector);\n  const dst = Math.sqrt(sqr);\n  const unit = scale(vector, dst > 0 ? 1 / dst : 0, vector.slice());\n  return {\n    vector,\n    sqr,\n    dist: dst,\n    unit,\n  };\n}\n\n/**\n * Get a unit vector that is perpendicular to the input vector. Only for 2d vectors!\n * @param {number[]} vector 2d vector\n * @param {number[]} target optional array/vector to store the resulting vector\n * @return {number[]} normalized, perpendicular vector\n */\nexport function orth2(vector, target = null) {\n  target = target || vector;\n  const x = -vector[1];\n  target[1] = vector[0];\n  target[0] = x;\n  return norm(target);\n}\n\n/**\n * Find the axis aligned angle of a 3d vector\n * @param {number[]} vector\n * @param {number} axis which axis to measure from X=0, Y=1, Z=2 (defaults to 0)\n * @return {number} angle in radians\n */\nexport function angle(vector, axis = 0) {\n  if (axis > 2 || axis < 0) return undefined;\n\n  const [x, y, z] = vector;\n  let a, b, c;\n  switch (axis) {\n    case 0: a = y; b = z; c = x; break;\n    case 1: a = x; b = z; c = y; break;\n    default: a = x; b = y; c = z;\n  }\n  const l = Math.sqrt(a ** 2 + b ** 2);\n  return Math.atan2(l, c);\n}\n\n/**\n * Find the axis aligned angle of a 2d vector\n * @param {number[]} vector\n * @return {number} angle in radians\n */\nexport function angle2(vector) {\n  return Math.atan2(vector[1], vector[0]);\n}\n\n/**\n * Get a unit vector between two points/coordinates. This function\n * does not mutate any arguments, but a target may still be used to\n * control the return type or to avoid creating additional arrays.\n * @param {number[]} from start coordinates\n * @param {number[]} to end coordinates\n * @param {number[]} target optional array/vector to store the resulting vector\n * @return {number[]} unit vector between from and to\n */\nexport function dir(from, to, target = null) {\n  return norm(vec(from, to, target));\n}\n\n/**\n * Calculate the distance between two points/coordinates.\n * @param {number[]} p1 point/coordinates\n * @param {number[]} p2 point/coordinates\n * @return {number} distance\n */\nexport function dist(p1, p2) {\n  return scalar(vec(p1, p2));\n}\n\n/**\n * Calculate the dot product between two vectors\n * @param {number[]} v1 left hand operand\n * @param {number[]} v2 right hand operand\n * @return {number} the dot product\n */\nexport function dot(v1, v2) {\n  return v1.reduce((sum, c, i) => sum + c * v2[i], 0);\n}\n\n/**\n * Find the cross product between two 3d vectors\n * @param {number[]} v1 left hand operand (3d vector)\n * @param {number[]} v2 right hand operand (3d vector)\n * @param {number[]} target optional array/vector to store the resulting vector\n * @return {number[]} the cross product vector (normal)\n */\nexport function cross(v1, v2, target = null) {\n  target = target || new Array(3);\n  target[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);\n  target[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);\n  target[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);\n\n  return target;\n}\n\n/**\n * Get the triple product between three 3d vectors\n * @param {number[]} v1 left hand operand for the dot product (3d vector)\n * @param {number[]} v2 left hand operand for the cross product (3d vector)\n * @param {number[]} v3 right hand operand for the cross product (3d vector)\n * @return {number} triple product\n */\nexport function triple(v1, v2, v3) {\n  return dot(v1, cross(v2, v3));\n}\n\n/**\n * Find the psudo cross product between two 2d vectors\n * @param {number[]} v1 left hand operand (2d vector)\n * @param {number[]} v2 right hand operand (2d vector)\n * @return {number} signed area of the parallellogram defined by v1 and v2\n */\nexport function cross2(v1, v2) {\n  return (v1[0] * v2[1]) - (v1[1] * v2[0]);\n}\n\n/**\n * Clamps the value to min or max if value is less than min or greater than max\n * @param {number} value value to clamp\n * @param {number} min minimum value\n * @param {number} max maximum value\n * @return {number} clamped value\n */\nexport function clampValue(value, min = 0, max = 1) {\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n}\n\n/**\n * Clamps each value in array according to min and max.\n * @param {number[]} arr values to clamp\n * @param {number} min minimum value\n * @param {number} max maximum value\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} array of clamped values\n */\nexport function clampArray(arr, min = 0, max = 1, target = null) {\n  target = target || arr;\n  for (let i = 0; i < target.length; i++) {\n    target[i] = clampValue(target[i], min, max);\n  }\n  return target;\n}\n\n/**\n * Clamps the argument according to min and max. Arg can be either a numeric\n * value or an array of numeric values.\n * @param {number|number[]} arg value or array of values to clamp\n * @param {number} min minimum value\n * @param {number} max maximum value\n * @param {number[]} target optional array/vector to store the result\n * @return {number|number[]} clamped version of arg\n */\nexport function clamp(arg, min = 0, max = 1, target = null) {\n  if (Array.isArray(arg)) {\n    return clampArray(arg, min, max, target);\n  }\n  return clampValue(arg, min, max);\n}\n\n/**\n * As glsl step function for single numeric values\n * @param {number} edge value to test\n * @param {number} x threshold value\n * @return {number} returns 0 or 1\n */\nexport function stepValue(edge, x) {\n  return x >= edge ? 1 : 0;\n}\n\n/**\n * As glsl step function for multiple numeric values\n * @param {number[]} edges values to test\n * @param {number|number[]} x threshold values\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} results for each value in edges\n */\nexport function stepArray(edges, x, target = null) {\n  const m = Array.isArray(x) ? i => x[i] : () => x;\n  target = target || edges;\n  for (let i = 0; i < target.length; i++) {\n    target[i] = stepValue(target[i], m(i));\n  }\n  return target;\n}\n\n/**\n * Implementation of glsl step function. Returns 0 if an edge is less than the\n * threshold x, otherwise 1\n * @param {number|number[]} edge number/array to test\n * @param {number|number[]} x threshold(s)\n * @param {number[]} target optional array/vector to store the result (if edge is array)\n * @return {number|number[]}\n */\nexport function step(edge, x, target = null) {\n  if (Array.isArray(edge)) {\n    return stepArray(edge, x, target);\n  }\n  return stepValue(edge, x);\n}\n\n/**\n * Implementation of glsl smoothstep function\n * @param {number} edge0\n * @param {number} edge1\n * @param {number} x threshold\n */\nexport function smoothstep(edge0, edge1, x) {\n  const t = clampValue((x - edge0) / (edge1 - edge0));\n  return t * t * (3.0 - 2.0 * t);\n}\n\n/**\n * Linear interpolation between two numbers\n * @param {number} a interpolate from\n * @param {number} b interpolate to\n * @param {number} t time 0 = a, 1 = b\n * @return {number} the interpolated value\n */\nexport function lerp(a, b, t) {\n  const m = clampValue(t, 0, 1);\n  return a * (1 - m) + b * m;\n}\n\n/**\n * Mix (interpolate) numbers or arrays (similar to glsl implementation).\n * Works on both vectors and matrices, since they are both arrays.\n * @param {number[]} a interpolate from\n * @param {number[]} b interpolate to\n * @param {number|number[]} t time 0 = a, 1 = b\n * @param {number[]} target optional array/vector to store the result\n * @return {number[]} interpolated array/vector/matrix\n */\nexport function mix(a, b, t, target = null) {\n  const m = Array.isArray(t) ? i => t[i] : () => t;\n  target = target || a;\n  for (let i = 0; i < target.length; i++) {\n    target[i] = lerp(a[i], b[i], m(i));\n  }\n  return target;\n}\n\n/**\n * Generates a list of interpolated values between from and to,\n * where the number of elements returned are controlled by the\n * steps argument.\n * @param {number|number[]} from value to interpolate from\n * @param {number|number[]} to value to interpolate to\n * @param {number} steps interpolation steps\n * @param {number} start start time of interpolation [0-1]\n * @param {number} end end time of interpolation [0-1]\n */\nexport function seq(from, to, steps, start = 0, end = 1) {\n  let f;\n  if (Array.isArray(from)) {\n    f = t => mix(from, to, t, from.slice());\n  } else {\n    f = t => lerp(from, to, t);\n  }\n  const target = [];\n  const incr = (end - start) / (steps - 1);\n  for (let i = 0; i < steps - 1; i++) {\n    const x = start + i * incr;\n    target.push(f(x));\n  }\n  target.push(f(end));\n  return target;\n}\n\n/**\n * Generates a list of interpolated values between 0 and 1,\n * where the number of elements returned are controlled by the\n * steps argument.\n * @param {number} steps interpolation steps\n */\nexport function seqI(steps) {\n  const target = [];\n  const incr = 1 / (steps - 1);\n  for (let i = 0; i < steps - 1; i++) {\n    target.push(lerp(0, 1, i * incr));\n  }\n  target.push(1);\n  return target;\n}\n\n/**\n * Rounds a number to the specific number of digits. Works with either a\n * single number or an array of numbers, which means it can be used with vectors and\n * matrices as well.\n * @param {number|number[]} v value to round\n * @param {number} digits number of digits to round to\n * @return {number} rounded value\n */\nexport function round(v, digits = 1) {\n  const f = 10 ** digits;\n  if (!Array.isArray(v)) {\n    return Math.round(v * f) / f;\n  }\n  for (let i = 0; i < v.length; i++) {\n    v[i] = Math.round(v[i] * f) / f;\n  }\n  return v;\n}\n\n/**\n * Convert degrees to radians\n * @param {number} d degrees\n * @returns {number} radians\n */\nexport function rad(d) {\n  return d * DEG2RAD;\n}\n\n/**\n * Convert radians to degrees\n * @param {number} r radians\n * @returns {number} degrees\n */\nexport function deg(r) {\n  return r * RAD2DEG;\n}\n\n/**\n * Normalise an angle to be between -PI to +PI\n * @param {number} r radians\n * @return {number} normalised angle\n */\nexport function nrad(r) {\n  const v = r % TAU;\n  return (v < 0 ? v + TAU : v);\n}\n\n/**\n * Test if a vector is a null vector\n * @param {number[]} v vector to test\n * @param {number} epsilon optional epsilon value\n */\nexport function isNullVec(v, epsilon = 0) {\n  return epsilon ? v.every(val => Math.abs(val) - epsilon <= 0) : v.every(val => val === 0);\n}\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/src/functions.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "function",
    "name": "add",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~add",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{add}",
    "description": "Component-wise addition of two arrays/vectors.\nIf target is NOT specified, the first argument will\nbe mutated. Target will be overwritten and NOT included in the sum.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "left operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "right operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array/vector"
    }
  },
  {
    "__docId__": 58,
    "kind": "function",
    "name": "addScaled",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~addScaled",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{addScaled}",
    "description": "Component-wise addition of one vector with a scaled version of another vector.\nIf target is NOT specified, the first argument will\nbe mutated. Target will be overwritten and NOT included in the sum.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "left operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "right operand"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor to apply to from-vector"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array/vector"
    }
  },
  {
    "__docId__": 59,
    "kind": "function",
    "name": "addAll",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~addAll",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{addAll}",
    "description": "Component-wise addition of a set of arrays/vectors.\nIf target is NOT specified, the first element in the set will\nbe mutated. Target (if it has valid values) WILL be included in the sum.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[][]"
        ],
        "spread": false,
        "optional": false,
        "name": "vectors",
        "description": "Array of equally length arrays/vectors (to be added)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to add into"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array/vector"
    }
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "sub",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~sub",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{sub}",
    "description": "Component-wise subtraction of two arrays/vectors.\nIf target is NOT specified, the first argument will\nbe mutated. Target will be overwritten and NOT included in the sum.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "left operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "right operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array/vector"
    }
  },
  {
    "__docId__": 61,
    "kind": "function",
    "name": "subScaled",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~subScaled",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{subScaled}",
    "description": "Component-wise addition of one vector with a scaled version of another vector.\nIf target is NOT specified, the first argument will\nbe mutated. Target will be overwritten and NOT included in the sum.",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "left operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "right operand"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor to apply to vector that will be subtracted"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array/vector"
    }
  },
  {
    "__docId__": 62,
    "kind": "function",
    "name": "subAll",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~subAll",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{subAll}",
    "description": "Component-wise subtraction of array/vector and all elements in vectors.\nIf target is NOT specified, the first argument will\nbe mutated. Target will be overwritten and NOT included in the sum.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "left operand"
      },
      {
        "nullable": null,
        "types": [
          "number[][]"
        ],
        "spread": false,
        "optional": false,
        "name": "vectors",
        "description": "right operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array/vector"
    }
  },
  {
    "__docId__": 63,
    "kind": "function",
    "name": "vec",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~vec",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{vec}",
    "description": "Create a vector from two points. This function will NOT mutate any\narguments unless 'target' is the same as 'from'.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "start coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "end coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the resulting vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "vector"
    }
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "scale",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~scale",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{scale}",
    "description": "Component-wise scaling of an array or vector",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "array/vector to scale"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "scaled array/vector"
    }
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "sumsqr",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~sumsqr",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{sumsqr}",
    "description": "Computes the sum of squares",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "array/vector to compute"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 66,
    "kind": "function",
    "name": "scalar",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~scalar",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{scalar}",
    "description": "Computes the scalar value (length) of a vector",
    "lineNumber": 195,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "array/vector to compute"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "norm",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~norm",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{norm}",
    "description": "Normalizes an array/vector",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "array/vector to notmalize"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "normalized array/vector"
    }
  },
  {
    "__docId__": 68,
    "kind": "function",
    "name": "descr",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~descr",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{descr}",
    "description": "Describes relationships between two points.",
    "lineNumber": 221,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "start coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "end coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vector: number[], sqr: number, distance: number, unit: number[]}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "orth2",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~orth2",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{orth2}",
    "description": "Get a unit vector that is perpendicular to the input vector. Only for 2d vectors!",
    "lineNumber": 250,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "2d vector"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the resulting vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "normalized, perpendicular vector"
    }
  },
  {
    "__docId__": 70,
    "kind": "function",
    "name": "angle",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~angle",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{angle}",
    "description": "Find the axis aligned angle of a 3d vector",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "axis",
        "description": "which axis to measure from X=0, Y=1, Z=2 (defaults to 0)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "angle in radians"
    }
  },
  {
    "__docId__": 71,
    "kind": "function",
    "name": "angle2",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~angle2",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{angle2}",
    "description": "Find the axis aligned angle of a 2d vector",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "angle in radians"
    }
  },
  {
    "__docId__": 72,
    "kind": "function",
    "name": "dir",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~dir",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{dir}",
    "description": "Get a unit vector between two points/coordinates. This function\ndoes not mutate any arguments, but a target may still be used to\ncontrol the return type or to avoid creating additional arrays.",
    "lineNumber": 296,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "start coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "end coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the resulting vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "unit vector between from and to"
    }
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "dist",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~dist",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{dist}",
    "description": "Calculate the distance between two points/coordinates.",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": "point/coordinates"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": "point/coordinates"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "distance"
    }
  },
  {
    "__docId__": 74,
    "kind": "function",
    "name": "dot",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~dot",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{dot}",
    "description": "Calculate the dot product between two vectors",
    "lineNumber": 316,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v1",
        "description": "left hand operand"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v2",
        "description": "right hand operand"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the dot product"
    }
  },
  {
    "__docId__": 75,
    "kind": "function",
    "name": "cross",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~cross",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{cross}",
    "description": "Find the cross product between two 3d vectors",
    "lineNumber": 327,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v1",
        "description": "left hand operand (3d vector)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v2",
        "description": "right hand operand (3d vector)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the resulting vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "the cross product vector (normal)"
    }
  },
  {
    "__docId__": 76,
    "kind": "function",
    "name": "triple",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~triple",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{triple}",
    "description": "Get the triple product between three 3d vectors",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v1",
        "description": "left hand operand for the dot product (3d vector)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v2",
        "description": "left hand operand for the cross product (3d vector)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v3",
        "description": "right hand operand for the cross product (3d vector)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "triple product"
    }
  },
  {
    "__docId__": 77,
    "kind": "function",
    "name": "cross2",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~cross2",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{cross2}",
    "description": "Find the psudo cross product between two 2d vectors",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v1",
        "description": "left hand operand (2d vector)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v2",
        "description": "right hand operand (2d vector)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "signed area of the parallellogram defined by v1 and v2"
    }
  },
  {
    "__docId__": 78,
    "kind": "function",
    "name": "clampValue",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~clampValue",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{clampValue}",
    "description": "Clamps the value to min or max if value is less than min or greater than max",
    "lineNumber": 364,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value to clamp"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": "minimum value"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": "maximum value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "clamped value"
    }
  },
  {
    "__docId__": 79,
    "kind": "function",
    "name": "clampArray",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~clampArray",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{clampArray}",
    "description": "Clamps each value in array according to min and max.",
    "lineNumber": 378,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "values to clamp"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": "minimum value"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": "maximum value"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "array of clamped values"
    }
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "clamp",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~clamp",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{clamp}",
    "description": "Clamps the argument according to min and max. Arg can be either a numeric\nvalue or an array of numeric values.",
    "lineNumber": 395,
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "value or array of values to clamp"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": "minimum value"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": "maximum value"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number",
        "number[]"
      ],
      "spread": false,
      "description": "clamped version of arg"
    }
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "stepValue",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~stepValue",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{stepValue}",
    "description": "As glsl step function for single numeric values",
    "lineNumber": 408,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "edge",
        "description": "value to test"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "threshold value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "returns 0 or 1"
    }
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "stepArray",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~stepArray",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{stepArray}",
    "description": "As glsl step function for multiple numeric values",
    "lineNumber": 419,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "edges",
        "description": "values to test"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "threshold values"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "results for each value in edges"
    }
  },
  {
    "__docId__": 83,
    "kind": "function",
    "name": "step",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~step",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{step}",
    "description": "Implementation of glsl step function. Returns 0 if an edge is less than the\nthreshold x, otherwise 1",
    "lineNumber": 436,
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "edge",
        "description": "number/array to test"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "threshold(s)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result (if edge is array)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number",
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 84,
    "kind": "function",
    "name": "smoothstep",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~smoothstep",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{smoothstep}",
    "description": "Implementation of glsl smoothstep function",
    "lineNumber": 449,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "edge0",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "edge1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "threshold"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "function",
    "name": "lerp",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~lerp",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{lerp}",
    "description": "Linear interpolation between two numbers",
    "lineNumber": 461,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "interpolate from"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "interpolate to"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "time 0 = a, 1 = b"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the interpolated value"
    }
  },
  {
    "__docId__": 86,
    "kind": "function",
    "name": "mix",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~mix",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{mix}",
    "description": "Mix (interpolate) numbers or arrays (similar to glsl implementation).\nWorks on both vectors and matrices, since they are both arrays.",
    "lineNumber": 475,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "interpolate from"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "interpolate to"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "time 0 = a, 1 = b"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to store the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "interpolated array/vector/matrix"
    }
  },
  {
    "__docId__": 87,
    "kind": "function",
    "name": "seq",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~seq",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{seq}",
    "description": "Generates a list of interpolated values between from and to,\nwhere the number of elements returned are controlled by the\nsteps argument.",
    "lineNumber": 494,
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "value to interpolate from"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "value to interpolate to"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "steps",
        "description": "interpolation steps"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": "start time of interpolation [0-1]"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "end time of interpolation [0-1]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "seqI",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~seqI",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{seqI}",
    "description": "Generates a list of interpolated values between 0 and 1,\nwhere the number of elements returned are controlled by the\nsteps argument.",
    "lineNumber": 517,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "steps",
        "description": "interpolation steps"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "function",
    "name": "round",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~round",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{round}",
    "description": "Rounds a number to the specific number of digits. Works with either a\nsingle number or an array of numbers, which means it can be used with vectors and\nmatrices as well.",
    "lineNumber": 535,
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to round"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "digits",
        "description": "number of digits to round to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "rounded value"
    }
  },
  {
    "__docId__": 90,
    "kind": "function",
    "name": "rad",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~rad",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{rad}",
    "description": "Convert degrees to radians",
    "lineNumber": 551,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} radians"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "d",
        "description": "degrees"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "radians"
    }
  },
  {
    "__docId__": 91,
    "kind": "function",
    "name": "deg",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~deg",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{deg}",
    "description": "Convert radians to degrees",
    "lineNumber": 560,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} degrees"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": "radians"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "degrees"
    }
  },
  {
    "__docId__": 92,
    "kind": "function",
    "name": "nrad",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~nrad",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{nrad}",
    "description": "Normalise an angle to be between -PI to +PI",
    "lineNumber": 569,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": "radians"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "normalised angle"
    }
  },
  {
    "__docId__": 93,
    "kind": "function",
    "name": "isNullVec",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~isNullVec",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/functions.js",
    "importStyle": "{isNullVec}",
    "description": "Test if a vector is a null vector",
    "lineNumber": 579,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "vector to test"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epsilon",
        "description": "optional epsilon value"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "src/index.js",
    "content": "export * from './vector';\nexport * from './matrix';\nexport * from './functions';\nexport * from './const';\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "file",
    "name": "src/matrix.js",
    "content": "import { rowsToColumns } from './utils';\nimport { scale } from './functions';\n\n/**\n * A class for storing values in rows and columns and for doing\n * common matrix operations. As the Vector class, this extends the\n * js Array class.\n *\n * Values are stores columns-first internally, but is normally\n * instantiated by supplying values in rows-first order.\n */\nexport class Matrix extends Array {\n  /**\n   * Creates an identity matrix with rows and columns equal to size.\n   * @param {number} size dimension\n   * @return {Matrix}\n   */\n  static identity(size = 4) {\n    const m = new Matrix(size).fill(0);\n    for (let i = 0; i < m.length; i += size + 1) {\n      m[i] = 1;\n    }\n    return m;\n  }\n\n  /**\n   * Traverse an array as a matrix, either rows-first or columns first.\n   * @param {number[]} arr array to traverse as a matrix\n   * @param {number} cols number of columns to split the array into\n   * @param {function} callback function to be executed for each element\n   * @param {boolean} rowsFirst traverse order\n   */\n  static traverse(arr, cols = 1, callback = () => ({}), rowsFirst = true) {\n    const rows = arr.rows || ~~(arr.length / cols);\n    if (rowsFirst) {\n      let n = 0;\n      for (let c = 0; c < cols; c++) {\n        for (let r = 0; r < rows; r++) {\n          const idx = c * rows + r;\n          callback(arr[idx], n++, r, c, idx);\n        }\n      }\n    } else {\n      arr.forEach((v, i) => callback(v, i, i % cols, ~~(i / rows), i));\n    }\n  }\n\n  /**\n   * Instantiate a matrix from an array.\n   * @param {number[]} arr array of numbers\n   * @param {number} columns number of columns to split the array into\n   * @param {boolean} rowsFirst traverse order\n   * @param {boolean} mutateArgs set if the input array should be mutated or not\n   * @return {Matrix}\n   */\n  static fromArray(arr, columns = 1, rowsFirst = true, mutateArgs = false) {\n    const rows = columns === 1 ? arr.length : ~~(arr.length / columns);\n\n    return new Matrix(rows, columns, arr, rowsFirst, mutateArgs);\n  }\n\n  /**\n   * Create a matrix from vectors. Each vector will be a column in the matrix\n   * and the number of rows are determined by the vector dimension.\n   * @param  {...number[]} vectors\n   * @return {Matrix}\n   */\n  static fromVectors(...vectors) {\n    const cols = vectors.length;\n    const rows = vectors[0].length;\n    const m = new Matrix(rows, cols);\n    let n = 0;\n    for (let i = 0; i < cols; i++) {\n      for (let j = 0; j < rows; j++) {\n        m[n++] = vectors[i][j];\n      }\n    }\n    return m;\n  }\n\n  /**\n   * Constructs a new instance of Matrix. If cols is omitted, it will mirror the rows\n   * parameter, making a square matrix.\n   * @param {number} rows number of rows\n   * @param {number} cols number of columns\n   * @param {number[]} values array of numbers to assign to the matrix elements\n   * @param {boolean} rowsFirst if values should be read rows-first or columns-first\n   * @param {boolean} mutateArgs set if the input array should be mutated or not\n   */\n  constructor(rows = 4, cols, values, rowsFirst = true, mutateArgs = false) {\n    cols = cols || rows;\n    super(rows * cols);\n    /** internal property to hold number of columns of this matrix */\n    this._c = cols;\n    /** internal property to hold number of rows of this matrix */\n    this._r = rows;\n\n    if (values) {\n      if (values.length === 1 && Array.isArray(values[0])) {\n        [values] = values;\n      }\n      this.copyFrom(values, rowsFirst, mutateArgs);\n    }\n  }\n\n  /**\n   * Set values of this matrix from an array\n   * @param {number[]} values array of numbers\n   * @param {boolean} rowsFirst if values should be read rows-first or columns-first\n   * @param {number} mutateArgs\n   */\n  copyFrom(values, rowsFirst = true, mutateArgs = false) {\n    if (!rowsFirst) {\n      for (let i = 0; i < Math.min(this.length, values.length); i++) {\n        /** assign value */\n        this[i] = values[i];\n      }\n    } else {\n      if (values.length > this.length) {\n        if (mutateArgs) {\n          values.length = this.length;\n        } else {\n          values = values.slice(0, this.length);\n        }\n      }\n      rowsToColumns(values, this.columns, this);\n    }\n    return this;\n  }\n\n  /**\n   * Traverse this matrix\n   * @param {function} callback function to be executed for each element\n   * @param {boolean} rowsFirst if values should be read rows-first or columns-first\n   * @return {Matrix} returns itself for chaining\n   */\n  traverse(callback = () => ({}), rowsFirst = true) {\n    Matrix.traverse(this, this.columns, callback, rowsFirst);\n    return this;\n  }\n\n  /**\n   * Clone/copy this matrix\n   * @return {Matrix}\n   */\n  clone() {\n    return new Matrix(this.rows, this.columns, this, false);\n  }\n\n  /**\n   * Calculate the internal 1d array index\n   * @param {number} row row index (zero-based)\n   * @param {number} col column index (zero-based)\n   */\n  index(row, col) {\n    return this.rows * col + row;\n  }\n\n  /**\n   * Get a matrix element value by row and column\n   * @param {number} row row index (zero-based)\n   * @param {number} col column index (zero-based)\n   * @return {number}\n   */\n  get(row, col) {\n    const idx = this.index(row, col);\n    return this[idx];\n  }\n\n  /**\n   * Set a value at the specified row and column\n   * @param {number} row row index (zero-based)\n   * @param {number} col column index (zero-based)\n   * @param {number} value value to set\n   * @return {Matrix} returns itself for chaining\n   */\n  set(row, col, value) {\n    const idx = this.index(row, col);\n    /** assign value */\n    this[idx] = value;\n    return this;\n  }\n\n  /**\n  * Calculate the matrix matrix product between this matrix and the passed matrices.\n  * in the order they appear.\n  *\n  * The left hand matrix number of columns must always match the right hand matrix number of rows.\n  * @param  {...Matrix} matrices\n  * @return {Matrix}\n  */\n  dotMat(...matrices) {\n    let m = this;\n    let target = this;\n    matrices.forEach((other) => {\n      target = m.clone();\n      if (m.columns !== other.rows) throw Error('Columns of left hand matrix must match rows of right hand matrix!');\n      let idx = 0;\n      for (let c = 0; c < other.columns; c++) {\n        for (let r = 0; r < m.rows; r++) {\n          let sum = 0;\n          for (let n = 0; n < m.columns; n++) {\n            sum += m.get(r, n) * other.get(n, c);\n          }\n          target[idx++] = sum;\n        }\n      }\n      m = target;\n    });\n    return target;\n  }\n\n  /**\n  * Calculate the matrix vector product between this matrix and the passed arrays/vectors.\n  *\n  * Since it is common to use homogeneous coordinates when doing matrix-vector multiplication,\n  * i.e. use 4x4 matrix for transforming 3d vectors, the vectors will be treated as if they had\n  * the same number of components as the matrix has columns. For vectors with a lower dimension\n  * than the number of columns in the matrix, the last component will be iterpreted as 1 and any\n  * in between as 0. In the opposite case, it will simply neglect excessive components.\n  * @param  {number[]} vec vector (as Array/Vector)\n  * @param {Vector|number[]} target optional array/vector to avoid mutating the vec argument\n  * @return {number[]} resulting vector (type depending on vec/target argument)\n  */\n  dotVec(vec, target = null) {\n    if (target) { // optimized for immutable input vector\n      for (let c = 0; c < this.columns; c++) {\n        const n = c * this.rows;\n        for (let r = 0; r < target.length; r++) {\n          if (c === 0) target[r] = 0;\n          let compVal = 0;\n          if (c < vec.length) {\n            compVal = vec[c];\n          } else if (c === this.rows - 1) {\n            compVal = 1;\n          }\n          target[r] += this[n + r] * compVal;\n        }\n      }\n      return target;\n    }\n    // optimized for mutation of input vector\n    const comp = new Array(vec.length);\n    for (let i = 0; i < vec.length; i++) {\n      comp[i] = vec[i];\n      vec[i] = 0;\n    }\n\n    for (let c = 0; c < this.columns; c++) {\n      const n = c * this.rows;\n      for (let r = 0; r < vec.length; r++) {\n        let compVal = 0;\n        if (c < comp.length) {\n          compVal = comp[c];\n        } else if (c === this.rows - 1) {\n          compVal = 1;\n        }\n        vec[r] += this[n + r] * compVal;\n      }\n    }\n    if (vec.length > this.rows) {\n      vec.length = this.rows;\n    }\n    return vec;\n  }\n\n  /**\n   * Calculate the matrix-matrix or matrix-vector product, depending on the type of\n   * the argument passed to the other-parameter.\n   * @param {number[]|Vector|Matrix} other {Array/Vector/Matrix}\n   * @param {Vector|number[]} target optional array/vector to avoid mutating input argument\n   * @return {Matrix|Vector|number[]} depending on input.\n   */\n  dot(other, target = null) {\n    if (other instanceof Matrix) {\n      return this.dotMat(other);\n    }\n    return this.dotVec(other, target);\n  }\n\n  /**\n   * Get the values from a specific column.\n   * @param {number} j zero-based column index\n   * @param {Vector|number[]} target optional array/vector to write values to\n   * @return {number[]} column values\n   */\n  col(j, target = null) {\n    target = target || new Array(this.rows);\n    const idx = j * this.rows;\n\n    for (let i = idx; i < idx + this.rows; i++) {\n      target[i - idx] = this[i];\n    }\n    return target;\n  }\n\n  /**\n   * Get the values from a specific row.\n   * @param {number} i zero-based row index\n   * @param {Vector|number[]} target optional array/vector to write values to\n   * @return {number[]} row values\n   */\n  row(i, target = null) {\n    target = target || new Array(this.columns);\n\n    for (let j = 0; j < this.columns; j++) {\n      target[j] = this[i + j * this.rows];\n    }\n    return target;\n  }\n\n  /**\n   * Create a submatrix from this matrix.\n   * @param {number} row zero-based row index\n   * @param {number} col zero-based column index\n   * @param {number} rows number of rows to include\n   * @param {number} cols number of columns to include\n   * @param {Matrix|number[]} target optional array/matrix to write values to\n   * @return {Matrix} submatrix\n   */\n  submatrix(row = 0, col = 0, rows = 2, cols = 2, target = null) {\n    const start = this.index(row, col);\n    const end = start + cols * this.rows;\n\n    let subm;\n    if (target) {\n      if (target instanceof Matrix) {\n        target._c = cols;\n        target._r = rows;\n        target.length = rows * cols;\n      }\n      subm = target;\n    } else {\n      subm = new Matrix(rows, cols);\n    }\n\n    let k = 0;\n    for (let i = start; i < end; i += this.rows) {\n      for (let j = 0; j < rows; j++) {\n        subm[k++] = this[i + j];\n      }\n    }\n    return subm;\n  }\n\n  /**\n   * Remove a row and/or column from this matrix\n   * @param {number} row zero-based row index (-1 or null to omit)\n   * @param {number} col zero-based column index (-1 or null to omit)\n   * @param {Matrix} target optional matrix to avoid mutating this matrix\n   * @return {Matrix} reduced matrix\n   */\n  remove(row = null, col = null, target = null) {\n    if (target && target instanceof Matrix) {\n      target._r = this._r;\n      target._c = this._c;\n      target.length = this.length;\n      target.copyFrom(this, false);\n    } else {\n      target = this;\n    }\n\n    let idx;\n    if (Number.isFinite(col) && col >= 0 && col < target.columns) {\n      idx = col * target.rows;\n      target.splice(idx, target.rows);\n      target._c--;\n    }\n    if (Number.isFinite(row) && row >= 0 && row < target.rows) {\n      for (let r = 0; r < target.columns; r++) {\n        idx = r * target.rows + row - r;\n        target.splice(idx, 1);\n      }\n      target._r--;\n    }\n    return target;\n  }\n\n  /**\n   * Transpose this matrix (switch rows and columns)\n   * @param {Matrix|number[]} target optional array/matrix to avoid mutating this matrix\n   * @return {Matrix} transposed matrix\n   */\n  transpose(target = null) {\n    const cols = this.rows;\n    if (!target) {\n      target = this;\n    } else {\n      target.length = this.length;\n    }\n    if (target instanceof Matrix) {\n      target._r = this._c;\n      target._c = cols;\n    }\n    rowsToColumns(this, cols, target);\n    return target;\n  }\n\n  /**\n   * Invert this matrix (where applicable)\n   * @param {Matrix} target optional matrix to avoid mutating this matrix\n   * @return {Matrix} transposed matrix\n   */\n  inverse(target = null) {\n    if (!this.isSquare) throw Error('Matrix must be square!');\n\n    const dim = this.rows;\n    if (target && target instanceof Matrix) {\n      target._c = this.columns;\n      target._r = this.rows;\n      target.length = this.length;\n      target.copyFrom(this, false);\n    } else {\n      target = this;\n    }\n    const src = Matrix.identity(dim);\n\n    for (let i = 0; i < dim; i++) {\n      const d = target.index(i, i);\n      let e = target[d];\n      // if we have a 0 on the diagonal (we'll need to swap with a lower row)\n      if (e === 0) {\n        // look through every row below the i'th row\n        for (let ii = i + 1; ii < dim; ii += 1) {\n          // if the ii'th row has a non-0 in the i'th col\n          if (target.get(ii, i) !== 0) {\n            // it would make the diagonal have a non-0 so swap it\n            for (let j = 0; j < dim; j++) {\n              const ij = target.index(i, j);\n              const iij = target.index(ii, j);\n              e = target[ij]; // temp store i'th row\n              target[ij] = target[iij]; // replace i'th row by ii'th\n              target[iij] = e; // repace ii'th by temp\n              e = src[ij]; // temp store i'th row\n              src[ij] = src[iij]; // replace i'th row by ii'th\n              src[iij] = e; // repace ii'th by temp\n            }\n            // don't bother checking other rows since we've swapped\n            break;\n          }\n        }\n        // get the new diagonal\n        e = target[d];\n        // if it's still 0, not srcertable (error)\n        if (e === 0) return undefined;\n      }\n\n      // Scale this row down by e (so we have a 1 on the diagonal)\n      for (let j = 0; j < dim; j++) {\n        const ij = target.index(i, j);\n        target[ij] /= e; // apply to original thisrix\n        src[ij] /= e; // apply to identity\n      }\n\n      // Subtract this row (scaled appropriately for each row) from ALL of\n      // the other rows so that there will be 0's in this column in the\n      // rows above and below this one\n      for (let ii = 0; ii < dim; ii++) {\n        // Only apply to other rows (we want a 1 on the diagonal)\n        if (ii === i) continue;\n\n        // We want to change this element to 0\n        e = target.get(ii, i);\n\n        // Subtract (the row above(or below) scaled by e) from (the\n        // current row) but start at the i'th column and assume all the\n        // stuff left of diagonal is 0 (which it should be if we made this\n        // algorithm correctly)\n        for (let j = 0; j < dim; j++) {\n          const ij = target.index(i, j);\n          const iij = target.index(ii, j);\n          target[iij] -= e * target[ij]; // apply to original matrix\n          src[iij] -= e * src[ij]; // apply to identity\n        }\n      }\n    }\n    return src;\n  }\n\n  /**\n   * Calculate this matrix's determinant (where applicable)\n   * @return {number} the determinant\n   */\n  determinant() {\n    if (!this.isSquare) throw Error('Matrix must be square!');\n\n    if (this.rows === 2) {\n      return this[0] * this[3] - this[2] * this[1];\n    } else if (this.rows === 3) {\n      return this[0] * this[4] * this[8] - this[6] * this[4] * this[2] +\n        this[3] * this[7] * this[2] - this[0] * this[7] * this[5] +\n        this[6] * this[1] * this[5] - this[3] * this[1] * this[8];\n    }\n\n    function determinantRec(m) {\n      if (m.length === 1) return m[0];\n\n      let d = 0;\n      for (let c = 0; c < m.columns; c++) {\n        const v = m[c * m.rows];\n        if (v === 0) continue;\n        const sm = m.remove(0, c, new Matrix());\n        let cofactor = determinantRec(sm);\n\n        if (c % 2 === 1) {\n          cofactor = -cofactor;\n        }\n        d += v * cofactor;\n      }\n      return d;\n    }\n\n    return determinantRec(this);\n  }\n\n  /**\n   * Scale this vector by a factor\n   * @param {number} factor scaling factor\n   * @param {Matrix|number[]} target optional array/matrix to avoid mutating this matrix\n   * @return {Matrix}\n   */\n  scale(factor, target = null) {\n    return scale(this, factor, target || this);\n  }\n\n  /**\n   * Returns a native javascript Array representation of this matrix, in rows-first order\n   * @return {number[]}\n   */\n  columnsFirst() {\n    return [...this];\n  }\n\n  /**\n   * Returns a native javascript Array representation of this matrix, in column-first order\n   * @return {number[]}\n   */\n  rowsFirst() {\n    const res = new Array(this.length);\n    rowsToColumns(this, this.rows, res);\n    return res;\n  }\n\n  /**\n   * Return a native javascript Array representation of this matrix.\n   * @param {boolean} rowsFirst if the output should be rows-first or columns-first\n   * @return {number[]}\n   */\n  toArray(rowsFirst = false) {\n    return rowsFirst ? this.rowsFirst() : this.columnsFirst();\n  }\n\n  /**\n   * Returns a 2d native javascript Array representation of this matrix.\n   * @param {boolean} rowsFirst if the output should be rows-first or columns-first\n   * @return {Array<Array>}\n   */\n  toArray2d(rowsFirst = false) {\n    const res = new Array(rowsFirst ? this.rows : this.columns);\n    const cf = rowsFirst ?\n      (v, i, r, c) => {\n        if (!res[r]) res[r] = new Array(this.columns);\n        res[r][c] = v;\n      } :\n      (v, i, r, c) => {\n        if (!res[c]) res[c] = new Array(this.rows);\n        res[c][r] = v;\n      };\n\n    this.traverse(cf);\n    return res;\n  }\n\n  /**\n   * Get the number of columns in this matrix.\n   * @return {number}\n   */\n  get columns() {\n    return this._c;\n  }\n\n  /**\n   * Get the number of rows in this matrix.\n   * @return {number}\n   */\n  get rows() {\n    return this._r;\n  }\n\n  /**\n   * This function returns true if this matrix has the same number of rows as columns,\n   * otherwise false.\n   * @return {boolan}\n   */\n  get isSquare() {\n    return this.rows === this.columns;\n  }\n}\n\n// add extra accessors\nfor (let i = 1; i <= 4; i++) {\n  for (let j = 1; j <= 4; j++) {\n    Object.defineProperty(Matrix.prototype, `a${i}${j}`, {\n      get() {\n        return this.get(i - 1, j - 1);\n      },\n      set(v) {\n        this.set(i - 1, j - 1, v);\n      },\n    });\n  }\n}\n\n/**\n * Factory function for creating and assigning a matrix from an array.\n * The array must be 1 dimensional, and will be split into rows and columns based\n * on the specified cols parameter. If array length divided by cols doesn't add up\n * to a whole number, then only floor(args.length / cols) values will be read from\n * the input array.\n *\n * Initial values are passed in row-first order by default, but can optionally\n * be passed in columns-first by setting the rowFirst argument to false.\n * @param  {...number} arr initial values\n * @param {number} cols number of columns to split the array into\n * @param {boolean} rowsFirst read arr in rows-first or column-first order\n * @return {Matrix}\n */\nexport function mat(arr, cols, rowsFirst = true) {\n  return Matrix.fromArray(arr, cols, rowsFirst, true);\n}\n\n/**\n * Factory function for creating and assigning a 2x2 matrix.\n * Initial values are passed in row-first order.\n * @param  {...number} args initial values\n * @return {Matrix}\n */\nexport function mat2(...args) {\n  return new Matrix(2, 2, args, true, true);\n}\n\n/**\n * Factory function for creating and assigning a 3x3 matrix.\n * Initial values are passed in row-first order.\n * @param  {...number} args initial values\n * @return {Matrix}\n */\nexport function mat3(...args) {\n  return new Matrix(3, 3, args, true, true);\n}\n\n/**\n * Factory function for creating and assigning a 4x4 matrix.\n * Initial values are passed in row-first order.\n * @param  {...number} args initial values\n * @return {Matrix}\n */\nexport function mat4(...args) {\n  return new Matrix(4, 4, args, true, true);\n}\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/src/matrix.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 96,
    "kind": "class",
    "name": "Matrix",
    "memberof": "src/matrix.js",
    "static": true,
    "longname": "src/matrix.js~Matrix",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/matrix.js",
    "importStyle": "{Matrix}",
    "description": "A class for storing values in rows and columns and for doing\ncommon matrix operations. As the Vector class, this extends the\njs Array class.\n\nValues are stores columns-first internally, but is normally\ninstantiated by supplying values in rows-first order.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "identity",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~Matrix.identity",
    "access": "public",
    "description": "Creates an identity matrix with rows and columns equal to size.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "size",
        "description": "dimension"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "traverse",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~Matrix.traverse",
    "access": "public",
    "description": "Traverse an array as a matrix, either rows-first or columns first.",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "array to traverse as a matrix"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cols",
        "description": "number of columns to split the array into"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "function to be executed for each element"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "traverse order"
      }
    ],
    "return": null
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "fromArray",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~Matrix.fromArray",
    "access": "public",
    "description": "Instantiate a matrix from an array.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "array of numbers"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "columns",
        "description": "number of columns to split the array into"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "traverse order"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "mutateArgs",
        "description": "set if the input array should be mutated or not"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "fromVectors",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~Matrix.fromVectors",
    "access": "public",
    "description": "Create a matrix from vectors. Each vector will be a column in the matrix\nand the number of rows are determined by the vector dimension.",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number[]"
        ],
        "spread": true,
        "optional": false,
        "name": "vectors",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 101,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#constructor",
    "access": "public",
    "description": "Constructs a new instance of Matrix. If cols is omitted, it will mirror the rows\nparameter, making a square matrix.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rows",
        "description": "number of rows"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cols",
        "description": "number of columns"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "array of numbers to assign to the matrix elements"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "if values should be read rows-first or columns-first"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "mutateArgs",
        "description": "set if the input array should be mutated or not"
      }
    ]
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "_c",
    "memberof": "src/matrix.js~Matrix",
    "static": false,
    "longname": "src/matrix.js~Matrix#_c",
    "access": "private",
    "description": "internal property to hold number of columns of this matrix",
    "lineNumber": 94,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "_r",
    "memberof": "src/matrix.js~Matrix",
    "static": false,
    "longname": "src/matrix.js~Matrix#_r",
    "access": "private",
    "description": "internal property to hold number of rows of this matrix",
    "lineNumber": 96,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "copyFrom",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#copyFrom",
    "access": "public",
    "description": "Set values of this matrix from an array",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "array of numbers"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "if values should be read rows-first or columns-first"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mutateArgs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "[i]",
    "memberof": "src/matrix.js~Matrix",
    "static": false,
    "longname": "src/matrix.js~Matrix#[i]",
    "access": "public",
    "description": "assign value",
    "lineNumber": 116,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "traverse",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#traverse",
    "access": "public",
    "description": "Traverse this matrix",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "function to be executed for each element"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "if values should be read rows-first or columns-first"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": "returns itself for chaining"
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "clone",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#clone",
    "access": "public",
    "description": "Clone/copy this matrix",
    "lineNumber": 146,
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "index",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#index",
    "access": "public",
    "description": "Calculate the internal 1d array index",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "row index (zero-based)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "column index (zero-based)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "get",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#get",
    "access": "public",
    "description": "Get a matrix element value by row and column",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "row index (zero-based)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "column index (zero-based)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "set",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#set",
    "access": "public",
    "description": "Set a value at the specified row and column",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "row index (zero-based)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "column index (zero-based)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": "returns itself for chaining"
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "[idx]",
    "memberof": "src/matrix.js~Matrix",
    "static": false,
    "longname": "src/matrix.js~Matrix#[idx]",
    "access": "public",
    "description": "assign value",
    "lineNumber": 180,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "dotMat",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#dotMat",
    "access": "public",
    "description": "Calculate the matrix matrix product between this matrix and the passed matrices.\nin the order they appear.\n\nThe left hand matrix number of columns must always match the right hand matrix number of rows.",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "...Matrix"
        ],
        "spread": true,
        "optional": false,
        "name": "matrices",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "dotVec",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#dotVec",
    "access": "public",
    "description": "Calculate the matrix vector product between this matrix and the passed arrays/vectors.\n\nSince it is common to use homogeneous coordinates when doing matrix-vector multiplication,\ni.e. use 4x4 matrix for transforming 3d vectors, the vectors will be treated as if they had\nthe same number of components as the matrix has columns. For vectors with a lower dimension\nthan the number of columns in the matrix, the last component will be iterpreted as 1 and any\nin between as 0. In the opposite case, it will simply neglect excessive components.",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vec",
        "description": "vector (as Array/Vector)"
      },
      {
        "nullable": null,
        "types": [
          "Vector",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating the vec argument"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "resulting vector (type depending on vec/target argument)"
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "dot",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#dot",
    "access": "public",
    "description": "Calculate the matrix-matrix or matrix-vector product, depending on the type of\nthe argument passed to the other-parameter.",
    "lineNumber": 274,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]",
          "Vector",
          "Matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "{Array/Vector/Matrix}"
      },
      {
        "nullable": null,
        "types": [
          "Vector",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating input argument"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix",
        "Vector",
        "number[]"
      ],
      "spread": false,
      "description": "depending on input."
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "col",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#col",
    "access": "public",
    "description": "Get the values from a specific column.",
    "lineNumber": 287,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "j",
        "description": "zero-based column index"
      },
      {
        "nullable": null,
        "types": [
          "Vector",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to write values to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "column values"
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "row",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#row",
    "access": "public",
    "description": "Get the values from a specific row.",
    "lineNumber": 303,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "zero-based row index"
      },
      {
        "nullable": null,
        "types": [
          "Vector",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to write values to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "row values"
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "submatrix",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#submatrix",
    "access": "public",
    "description": "Create a submatrix from this matrix.",
    "lineNumber": 321,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "zero-based row index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "zero-based column index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rows",
        "description": "number of rows to include"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cols",
        "description": "number of columns to include"
      },
      {
        "nullable": null,
        "types": [
          "Matrix",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/matrix to write values to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": "submatrix"
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "remove",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#remove",
    "access": "public",
    "description": "Remove a row and/or column from this matrix",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "zero-based row index (-1 or null to omit)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "zero-based column index (-1 or null to omit)"
      },
      {
        "nullable": null,
        "types": [
          "Matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional matrix to avoid mutating this matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": "reduced matrix"
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "transpose",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#transpose",
    "access": "public",
    "description": "Transpose this matrix (switch rows and columns)",
    "lineNumber": 384,
    "params": [
      {
        "nullable": null,
        "types": [
          "Matrix",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/matrix to avoid mutating this matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": "transposed matrix"
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "inverse",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#inverse",
    "access": "public",
    "description": "Invert this matrix (where applicable)",
    "lineNumber": 404,
    "params": [
      {
        "nullable": null,
        "types": [
          "Matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional matrix to avoid mutating this matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": "transposed matrix"
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "determinant",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#determinant",
    "access": "public",
    "description": "Calculate this matrix's determinant (where applicable)",
    "lineNumber": 484,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the determinant"
    },
    "params": []
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "scale",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#scale",
    "access": "public",
    "description": "Scale this vector by a factor",
    "lineNumber": 522,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor"
      },
      {
        "nullable": null,
        "types": [
          "Matrix",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/matrix to avoid mutating this matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "columnsFirst",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#columnsFirst",
    "access": "public",
    "description": "Returns a native javascript Array representation of this matrix, in rows-first order",
    "lineNumber": 530,
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "rowsFirst",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#rowsFirst",
    "access": "public",
    "description": "Returns a native javascript Array representation of this matrix, in column-first order",
    "lineNumber": 538,
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#toArray",
    "access": "public",
    "description": "Return a native javascript Array representation of this matrix.",
    "lineNumber": 549,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "if the output should be rows-first or columns-first"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "toArray2d",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#toArray2d",
    "access": "public",
    "description": "Returns a 2d native javascript Array representation of this matrix.",
    "lineNumber": 558,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "if the output should be rows-first or columns-first"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 127,
    "kind": "get",
    "name": "columns",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#columns",
    "access": "public",
    "description": "Get the number of columns in this matrix.",
    "lineNumber": 578,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "get",
    "name": "rows",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#rows",
    "access": "public",
    "description": "Get the number of rows in this matrix.",
    "lineNumber": 586,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "get",
    "name": "isSquare",
    "memberof": "src/matrix.js~Matrix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matrix.js~Matrix#isSquare",
    "access": "public",
    "description": "This function returns true if this matrix has the same number of rows as columns,\notherwise false.",
    "lineNumber": 595,
    "return": {
      "nullable": null,
      "types": [
        "boolan"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "function",
    "name": "mat",
    "memberof": "src/matrix.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~mat",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/matrix.js",
    "importStyle": "{mat}",
    "description": "Factory function for creating and assigning a matrix from an array.\nThe array must be 1 dimensional, and will be split into rows and columns based\non the specified cols parameter. If array length divided by cols doesn't add up\nto a whole number, then only floor(args.length / cols) values will be read from\nthe input array.\n\nInitial values are passed in row-first order by default, but can optionally\nbe passed in columns-first by setting the rowFirst argument to false.",
    "lineNumber": 628,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "arr",
        "description": "initial values"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cols",
        "description": "number of columns to split the array into"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "rowsFirst",
        "description": "read arr in rows-first or column-first order"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 131,
    "kind": "function",
    "name": "mat2",
    "memberof": "src/matrix.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~mat2",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/matrix.js",
    "importStyle": "{mat2}",
    "description": "Factory function for creating and assigning a 2x2 matrix.\nInitial values are passed in row-first order.",
    "lineNumber": 638,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 132,
    "kind": "function",
    "name": "mat3",
    "memberof": "src/matrix.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~mat3",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/matrix.js",
    "importStyle": "{mat3}",
    "description": "Factory function for creating and assigning a 3x3 matrix.\nInitial values are passed in row-first order.",
    "lineNumber": 648,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 133,
    "kind": "function",
    "name": "mat4",
    "memberof": "src/matrix.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/matrix.js~mat4",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/matrix.js",
    "importStyle": "{mat4}",
    "description": "Factory function for creating and assigning a 4x4 matrix.\nInitial values are passed in row-first order.",
    "lineNumber": 658,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "src/utils.js",
    "content": "/**\n * Transpose a single dimensional array, representing 2d data, from\n * rows first to columns first.\n * @param {number[]} arr Array to transpose\n * @param {number} cols Number of columns in source array\n * @param {number[]} target If omitted, result will be returned as a new array\n */\nexport function rowsToColumns(arr, cols, target = null) {\n  cols = cols || 1;\n  const rows = cols === 1 ? arr.length : ~~(arr.length / cols);\n\n  if (target) {\n    if (target === arr) {\n      arr = [...arr]; // copy\n    }\n  } else {\n    target = new Array(rows * cols);\n  }\n\n  let n = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      target[rows * j + i] = arr[n++];\n    }\n  }\n  return target;\n}\n\n/**\n * Recursive function used by flattenList\n * @param {number[]} array array to be flattended\n * @param {number[]} flattend resulting array of values\n * @param {number} max max returned values (default is 0 for all)\n */\nfunction flatRec(array, flattend, max) {\n  for (let i = 0; i < array.length; i++) {\n    if (max && flattend.length === max) return;\n    const el = array[i];\n    if (Array.isArray(el)) flatRec(el, flattend, max);\n    else flattend.push(el);\n  }\n}\n\n/**\n * Recursivly flattens a list of arguments to a 1 dimensional array\n * @param {number[]} arg Arguments to be flattended\n * @param {number[]} flattend Resulting array of values\n * @param {number} max Max returned values (default is 0 for all)\n */\nexport function flattenList(arg = [], flattend = [], max = 0) {\n  if (flattend.length > 0) flattend.length = 0;\n  flatRec(arg, flattend, max);\n  return flattend;\n}\n\n/**\n * @ignore\n * Experimental! This function will create a wrapper function\n * that turns the input function into an immutable version,\n * by following the convention where the target-argument is\n * used to control which object is used to assign values to.\n * @param {function} fn function to create immutable version of.\n * The input-function must have a parameter named 'target', which\n * must be of type array and be the last parameter in the parameter\n * list.\n */\nexport function immutable(fn) {\n  if (!fn.toString().includes('var target='))\n    throw Error('Unable to create an immutable version of this function!');\n  return function wrapper(...args) {\n    if (args.length === 0) {\n      return fn([]);\n    } else if (Array.isArray(args[0])) {\n      return fn(...args, args[0].slice());\n    }\n    throw Error('Unable to execute immutable function!');\n  };\n}\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/src/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "function",
    "name": "rowsToColumns",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~rowsToColumns",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/utils.js",
    "importStyle": "{rowsToColumns}",
    "description": "Transpose a single dimensional array, representing 2d data, from\nrows first to columns first.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "Array to transpose"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cols",
        "description": "Number of columns in source array"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "If omitted, result will be returned as a new array"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "function",
    "name": "flatRec",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~flatRec",
    "access": "public",
    "export": false,
    "importPath": "@kjerandp/linear-algebra/src/utils.js",
    "importStyle": null,
    "description": "Recursive function used by flattenList",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "array to be flattended"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "flattend",
        "description": "resulting array of values"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": "max returned values (default is 0 for all)"
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "function",
    "name": "flattenList",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~flattenList",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/utils.js",
    "importStyle": "{flattenList}",
    "description": "Recursivly flattens a list of arguments to a 1 dimensional array",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "Arguments to be flattended"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "flattend",
        "description": "Resulting array of values"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": "Max returned values (default is 0 for all)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "function",
    "name": "immutable",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~immutable",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/utils.js",
    "importStyle": "{immutable}",
    "description": "",
    "lineNumber": 67,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "function to create immutable version of.\nThe input-function must have a parameter named 'target', which\nmust be of type array and be the last parameter in the parameter\nlist."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "file",
    "name": "src/vector.js",
    "content": "/* eslint-disable object-property-newline */\nimport {\n  add,\n  addAll,\n  addScaled,\n  sub,\n  subAll,\n  subScaled,\n  scale,\n  norm,\n  dot,\n  cross,\n  cross2,\n  dist,\n  scalar,\n  isNullVec,\n} from './functions';\nimport { flattenList } from './utils';\n\n/** mapping of additional accessors to array index */\nconst accessors = ({\n  x: 0, r: 0, i: 0, s: 0,\n  y: 1, g: 1, j: 1, t: 1,\n  z: 2, b: 2, k: 2, u: 2,\n  w: 3, a: 3, l: 3, v: 3,\n});\n\n/**\n * Simple extension to js Array to allow function chaining when doing vector operations.\n * A vector instance can be used the same way as a native Array instance. Note that length will\n * therefore return the number of vector components, and not its scalar value.\n * Use the scalar function if you want to know the vector's length.\n *\n * Instantiate a vector by its constructor or using one of the factory functions (vec2, vec3...)\n */\n\nexport class Vector extends Array {\n  /**\n   * Instantiate a vector from an array.\n   * @param {number[]} arr array of numbers\n   * @return {Vector}\n   */\n  static fromArray(arr) {\n    return new Vector(...arr);\n  }\n\n  /**\n   * Add one or more vectors to this vector\n   * @param  {...number[]} vectors vectors to add to this\n   * @return {Vector}\n   */\n  add(...vectors) {\n    if (vectors.length === 1) {\n      return add(this, vectors[0]);\n    }\n    return addAll(vectors, this);\n  }\n\n  /**\n   * Add a scaled version of a vector to this vector\n   * @param  {number[]} vector vectors to add to this\n   * @param {number} factor scaling factor\n   * @return {Vector}\n   */\n  addScaled(vector, factor) {\n    return addScaled(this, vector, factor, this);\n  }\n\n  /**\n   * Subtract one or more vectors from this vector\n   * @param  {...number[]} vectors vectors to subtract from this vector\n   * @return {Vector}\n   */\n  sub(...vectors) {\n    if (vectors.length === 1) {\n      return sub(this, vectors[0]);\n    }\n    return subAll(this, vectors);\n  }\n\n\n  /**\n   * Subtract a scaled version of a vector from this vector\n   * @param  {number[]} vector vector to subtract from this\n   * @param {number} factor scaling factor\n   * @return {Vector}\n   */\n  subScaled(vector, factor) {\n    return subScaled(this, vector, factor, this);\n  }\n\n  /**\n   * Calculate the scalar product (length) of this vector.\n   * @return {number}\n   */\n  scalar() {\n    return scalar(this);\n  }\n\n  /**\n   * Scale this vector by a factor\n   * @param {number} factor scaling factor\n   * @param {Array/Vector} target optional array/vector to avoid mutating this vector\n   * @return {Vector}\n   */\n  scale(factor, target = null) {\n    return scale(this, factor, target || this);\n  }\n\n  /**\n   * Negate all components of this vector\n   * @param {Array/Vector} target optional array/vector to avoid mutating this vector\n   * @return {Vector}\n   */\n  negate(target = null) {\n    return this.scale(-1, target);\n  }\n\n  /**\n   * Normalize this vector\n   * @param {Array/Vector} target optional array/vector to avoid mutating this vector\n   * @return {Vector}\n   */\n  normalize(target = null) {\n    return norm(this, target || this);\n  }\n\n  /**\n   * Calculate the dot product between this vector and the passed in argument\n   * @param {number[]} other vector\n   * @return {number} dot product\n   */\n  dot(other) {\n    return dot(this, other);\n  }\n\n  /**\n   * Find the cross product vector between this vector and the passed in argument.\n   * Only for 3d vectors!\n   * @param {number[]} other 3d vector\n   * @param {Array/Vector} target optional array/vector to avoid mutating this vector\n   * @return {Vector}\n   */\n  cross(other, target = null) {\n    return cross(this, other, target);\n  }\n\n  /**\n   * Calculate the psudo cross product between this vector and the passed in argument.\n   * Only for 2d vectors!\n   * @param {number[]} other 2d vector\n   * @return {number} psudo cross product\n   */\n  cross2(other) {\n    return cross2(this, other);\n  }\n\n  /**\n   * Calculate the distance between this coordinates to the coordinates supplied in the argument\n   * @param {number[]} other coordinates\n   * @return {number} distance\n   */\n  distance(other) {\n    return dist(this, other);\n  }\n\n  /**\n   * Clone/copy vector\n   * @return {Vector}\n   */\n  clone() {\n    return new Vector(...this);\n  }\n\n  /**\n   * Mimic the swizzle feature in glsl. Supply the swizzle pattern as a string, using the\n   * defined accessors (xyzw, rgba, ijkl or stuv):\n   * ex: vec.swizzle('xxyw') or vec.swizzle('rrra)\n   * @param {string} pattern swizzle pattern\n   * @param {Array/Vector} target optional array/vector to avoid mutating this vector\n   * @return {Vector}\n   */\n  swizzle(pattern, target = null) {\n    let values = this;\n    if (!target) {\n      target = this;\n      values = [...this];\n    }\n    const l = target.length || pattern.length;\n    for (let i = 0; i < l; i++) {\n      const ai = accessors[pattern[i]];\n      target[i] = values[ai];\n    }\n    return target;\n  }\n\n  /**\n   * Test if this vector is a null vector\n   * @param {number} epsilon epsilon\n   */\n  isNull(epsilon = 0) {\n    return isNullVec(this, epsilon);\n  }\n\n  /**\n   * Assign values to this vector\n   * @param  {...number} v values to set\n   * @return {Vector}\n   */\n  set(...v) {\n    for (let i = 0; i < v.length; i++) {\n      /** assign value */\n      this[i] = v[i];\n    }\n    return this;\n  }\n}\n\n// add getters and setters from accessors\nObject.keys(accessors).forEach((a) => {\n  Object.defineProperty(Vector.prototype, a, {\n    get() {\n      return this[accessors[a]];\n    },\n    set(v) {\n      if (Number.isFinite(v)) {\n        this[accessors[a]] = v;\n      }\n    },\n  });\n});\n\n/**\n * Create a vector of specific dimension and optionally set its values.\n * If values contains only one element, the all components will be set to\n * this value. Elements in values exceeding the specified dimension will\n * be neglected.\n * @param {number} dim the number of components\n * @param {Array<number>} values optional initial values\n * @return {Vector}\n */\nexport function nvec(dim = 0, values = [0]) {\n  if (values.length === 1 && Number.isFinite(values[0])) {\n    return new Vector(dim).fill(values[0]);\n  }\n  const v = new Vector();\n  flattenList(values, v, dim);\n  for (let i = v.length; i < dim; i++) {\n    v.push(0);\n  }\n  return v;\n}\n\n/**\n * Factory function for creating and assigning a 2d vector. If a single\n * argument is passed, then all components will be assigned with its value.\n * Missing initial values will be filled with zeros.\n * @param  {...number} args initial values\n * @return {Vector}\n */\nexport function vec2(...args) {\n  return nvec(2, args);\n}\n\n/**\n * Factory function for creating and assigning a 3d vector. If a single\n * argument is passed, then all components will be assigned with its value.\n * Missing initial values will be filled with zeros.\n * @param  {...number} args initial values\n * @return {Vector}\n */\nexport function vec3(...args) {\n  return nvec(3, args);\n}\n\n/**\n * Factory function for creating and assigning a 4d vector. If a single\n * argument is passed, then all components will be assigned with its value.\n * Missing initial values will be filled with zeros.\n * @param  {...number} args initial values\n * @return {Vector}\n */\nexport function vec4(...args) {\n  return nvec(4, args);\n}\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/src/vector.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "accessors",
    "memberof": "src/vector.js",
    "static": true,
    "longname": "src/vector.js~accessors",
    "access": "public",
    "export": false,
    "importPath": "@kjerandp/linear-algebra/src/vector.js",
    "importStyle": null,
    "description": "mapping of additional accessors to array index",
    "lineNumber": 21,
    "type": {
      "types": [
        "{\"x\": *, \"r\": *, \"i\": *, \"s\": *, \"y\": number, \"g\": number, \"j\": number, \"t\": number, \"z\": number, \"b\": number, \"k\": number, \"u\": number, \"w\": number, \"a\": number, \"l\": number, \"v\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "class",
    "name": "Vector",
    "memberof": "src/vector.js",
    "static": true,
    "longname": "src/vector.js~Vector",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/vector.js",
    "importStyle": "{Vector}",
    "description": "Simple extension to js Array to allow function chaining when doing vector operations.\nA vector instance can be used the same way as a native Array instance. Note that length will\ntherefore return the number of vector components, and not its scalar value.\nUse the scalar function if you want to know the vector's length.\n\nInstantiate a vector by its constructor or using one of the factory functions (vec2, vec3...)",
    "lineNumber": 37,
    "interface": false,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "fromArray",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/vector.js~Vector.fromArray",
    "access": "public",
    "description": "Instantiate a vector from an array.",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "array of numbers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "add",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#add",
    "access": "public",
    "description": "Add one or more vectors to this vector",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number[]"
        ],
        "spread": true,
        "optional": false,
        "name": "vectors",
        "description": "vectors to add to this"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "addScaled",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#addScaled",
    "access": "public",
    "description": "Add a scaled version of a vector to this vector",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "vectors to add to this"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "sub",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#sub",
    "access": "public",
    "description": "Subtract one or more vectors from this vector",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number[]"
        ],
        "spread": true,
        "optional": false,
        "name": "vectors",
        "description": "vectors to subtract from this vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "subScaled",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#subScaled",
    "access": "public",
    "description": "Subtract a scaled version of a vector from this vector",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": "vector to subtract from this"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "scalar",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#scalar",
    "access": "public",
    "description": "Calculate the scalar product (length) of this vector.",
    "lineNumber": 96,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "scale",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#scale",
    "access": "public",
    "description": "Scale this vector by a factor",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "factor",
        "description": "scaling factor"
      },
      {
        "nullable": null,
        "types": [
          "Array/Vector"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating this vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "negate",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#negate",
    "access": "public",
    "description": "Negate all components of this vector",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array/Vector"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating this vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "normalize",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#normalize",
    "access": "public",
    "description": "Normalize this vector",
    "lineNumber": 124,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array/Vector"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating this vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "dot",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#dot",
    "access": "public",
    "description": "Calculate the dot product between this vector and the passed in argument",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "dot product"
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "cross",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#cross",
    "access": "public",
    "description": "Find the cross product vector between this vector and the passed in argument.\nOnly for 3d vectors!",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "3d vector"
      },
      {
        "nullable": null,
        "types": [
          "Array/Vector"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating this vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "cross2",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#cross2",
    "access": "public",
    "description": "Calculate the psudo cross product between this vector and the passed in argument.\nOnly for 2d vectors!",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "2d vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "psudo cross product"
    }
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "distance",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#distance",
    "access": "public",
    "description": "Calculate the distance between this coordinates to the coordinates supplied in the argument",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "coordinates"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "distance"
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "clone",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#clone",
    "access": "public",
    "description": "Clone/copy vector",
    "lineNumber": 171,
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "swizzle",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#swizzle",
    "access": "public",
    "description": "Mimic the swizzle feature in glsl. Supply the swizzle pattern as a string, using the\ndefined accessors (xyzw, rgba, ijkl or stuv):\nex: vec.swizzle('xxyw') or vec.swizzle('rrra)",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "swizzle pattern"
      },
      {
        "nullable": null,
        "types": [
          "Array/Vector"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "optional array/vector to avoid mutating this vector"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "isNull",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#isNull",
    "access": "public",
    "description": "Test if this vector is a null vector",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epsilon",
        "description": "epsilon"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "set",
    "memberof": "src/vector.js~Vector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/vector.js~Vector#set",
    "access": "public",
    "description": "Assign values to this vector",
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "v",
        "description": "values to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "[i]",
    "memberof": "src/vector.js~Vector",
    "static": false,
    "longname": "src/vector.js~Vector#[i]",
    "access": "public",
    "description": "assign value",
    "lineNumber": 213,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "function",
    "name": "nvec",
    "memberof": "src/vector.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/vector.js~nvec",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/vector.js",
    "importStyle": "{nvec}",
    "description": "Create a vector of specific dimension and optionally set its values.\nIf values contains only one element, the all components will be set to\nthis value. Elements in values exceeding the specified dimension will\nbe neglected.",
    "lineNumber": 242,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dim",
        "description": "the number of components"
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "optional initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 161,
    "kind": "function",
    "name": "vec2",
    "memberof": "src/vector.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/vector.js~vec2",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/vector.js",
    "importStyle": "{vec2}",
    "description": "Factory function for creating and assigning a 2d vector. If a single\nargument is passed, then all components will be assigned with its value.\nMissing initial values will be filled with zeros.",
    "lineNumber": 261,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 162,
    "kind": "function",
    "name": "vec3",
    "memberof": "src/vector.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/vector.js~vec3",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/vector.js",
    "importStyle": "{vec3}",
    "description": "Factory function for creating and assigning a 3d vector. If a single\nargument is passed, then all components will be assigned with its value.\nMissing initial values will be filled with zeros.",
    "lineNumber": 272,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 163,
    "kind": "function",
    "name": "vec4",
    "memberof": "src/vector.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/vector.js~vec4",
    "access": "public",
    "export": true,
    "importPath": "@kjerandp/linear-algebra/src/vector.js",
    "importStyle": "{vec4}",
    "description": "Factory function for creating and assigning a 4d vector. If a single\nargument is passed, then all components will be assigned with its value.\nMissing initial values will be filled with zeros.",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "...number"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "initial values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vector"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "kind": "index",
    "content": "# Linear algebra\n\nMath library for doing basic linear algebra operations, inspired by GLSL.\n\n## Installation\n```\nnpm install --save @kjerandp/linear-algebra\n```\n## Usage\n\nThe package exports an object containing all types and functions. \n\n```js\n// es6\nimport { vec3, mat3, ... } from '@kjerandp/linear-algebra';\n\n// commonjs\nconst lib = require('@kjerandp/linear-algebra');\n\nconst vec3 = lib.vec3;\nconst mat3 = lib.mat3;\n(...)\n```\n\nSee this [live sample](https://observablehq.com/@kjerandp/affine-transformations) of usage or refer to the [docs](https://kjerandp.github.io/linear-algebra/) and tests for more details.\n\n## License\nMIT\n",
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"private\": false,\n  \"name\": \"@kjerandp/linear-algebra\",\n  \"version\": \"1.0.5\",\n  \"description\": \"Math library for doing basic linear algebra operations\",\n  \"repository\": \"https://github.com/kjerandp/linear-algebra\",\n  \"author\": \"Kjerand Pedersen\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"vector\",\n    \"math\",\n    \"matrix\",\n    \"matricies\",\n    \"linear\",\n    \"algebra\",\n    \"transformations\",\n    \"2d\",\n    \"3d\",\n    \"4d\"\n  ],\n  \"main\": \"dist/cjs/index.js\",\n  \"module\": \"dist/esm/index.js\",\n  \"browser\": \"dist/linear-algebra.min.js\",\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.4.4\",\n    \"@babel/core\": \"^7.4.4\",\n    \"@babel/preset-env\": \"^7.4.4\",\n    \"@babel/register\": \"^7.4.4\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^4.18.2\",\n    \"eslint-config-airbnb\": \"^16.1.0\",\n    \"eslint-plugin-import\": \"^2.9.0\",\n    \"eslint-plugin-jsx-a11y\": \"^6.0.3\",\n    \"eslint-plugin-react\": \"^7.7.0\",\n    \"expect\": \"^24.8.0\",\n    \"mocha\": \"^6.1.4\",\n    \"nyc\": \"^14.1.1\",\n    \"rollup\": \"^1.11.3\",\n    \"rollup-plugin-babel\": \"^4.3.2\",\n    \"rollup-plugin-uglify\": \"^6.0.2\"\n  },\n  \"scripts\": {\n    \"build\": \"node node_modules/.bin/rollup -c\",\n    \"dev\": \"node node_modules/.bin/rollup -c -w\",\n    \"coverage\": \"NODE_ENV=test npx nyc --reporter=html --reporter=text mocha --require @babel/register\",\n    \"test\": \"NODE_ENV=test npx mocha --require @babel/register\",\n    \"test:watch\": \"NODE_ENV=test npx mocha --require @babel/register --reporter min --watch\",\n    \"lint\": \"npx eslint src test tools\",\n    \"prepub\": \"npm run build\",\n    \"pub\": \"npm publish --access=public\",\n    \"docs\": \"./node_modules/.bin/esdoc\"\n  },\n  \"files\": [\n    \"dist\"\n  ]\n}\n",
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 164,
    "kind": "testFile",
    "name": "test/functions.spec.js",
    "content": "import expect from 'expect';\nimport {\n  vec,\n  add,\n  addAll,\n  addScaled,\n  sub,\n  subAll,\n  subScaled,\n  sumsqr,\n  scalar,\n  norm,\n  scale,\n  dist,\n  dir,\n  orth2,\n  descr,\n  angle2,\n  angle,\n  dot,\n  cross,\n  cross2,\n  triple,\n  clamp,\n  step,\n  smoothstep,\n  mix,\n  round,\n  lerp,\n  deg,\n  rad,\n  nrad,\n  seq,\n  seqI,\n  isNullVec,\n} from '../src/functions';\nimport { PI, TAU, SPI, QPI } from '../src/const';\nimport { Vector, vec2, vec3, vec4 } from '../src/vector';\nimport { Matrix, mat2 } from '../src/matrix';\n\ndescribe('functions.js', () => {\n  it('should be able to create a vector from two points', () => {\n    const p1 = [-1, 0, 2];\n    const p2 = [2, -3, 1];\n\n    expect(vec(p1, p2)).toEqual([3, -3, -1]);\n    // supply empty array as target\n    expect(vec(p1, p2, [])).toEqual([3, -3, -1]);\n    // supply array with a specific length\n    expect(vec(p1, p2, new Array(2))).toEqual([3, -3]);\n    // supply vector as target\n    expect(vec(p1, p2, new Vector(3))).toBeInstanceOf(Vector);\n  });\n\n  it('should be able to add and subtract vectors/arrays', () => {\n    /* single */\n    const v1 = vec3(1, 2, 3);\n    const v2 = vec3(2, -2, -1);\n\n    const a1 = [1, 2, 3];\n    const a2 = [2, -2, -1];\n\n    let res = add(v1, v2, new Vector());\n    expect(res).toEqual([3, 0, 2]);\n    expect(res).toBeInstanceOf(Vector);\n\n    res = add(a1, a2, new Vector());\n    expect(res).toEqual([3, 0, 2]);\n    expect(res).toBeInstanceOf(Vector);\n\n    // only add first two components into a 2d vector\n    res = add(v1, v2, new Vector(2));\n    expect(res).toEqual([3, 0]);\n\n    res = add(a1, a2, new Vector(2));\n    expect(res).toEqual([3, 0]);\n\n    // add scaled vector\n    res = addScaled(v1, v2, 2, new Vector(3));\n    expect(res).toEqual([5, -2, 1]);\n\n    // sub scaled vector\n    res = subScaled(v1, v2, 2, new Vector(3));\n    expect(res).toEqual([-3, 6, 5]);\n\n    // mutate first argument by not specifying a target\n    res = add(v1, v2);\n    expect(res).toBe(v1);\n    expect(v1).toEqual([3, 0, 2]);\n\n    // mutate scaled\n    v1.set(1, 2, 3);\n    res = addScaled(v1, v2, 2);\n    expect(res).toEqual([5, -2, 1]);\n    expect(res).toBe(v1);\n    expect(v2).toEqual([2, -2, -1]); // should not be mutated\n\n    v1.set(1, 2, 3);\n    res = subScaled(v1, v2, 2);\n    expect(res).toEqual([-3, 6, 5]);\n    expect(res).toBe(v1);\n    expect(v2).toEqual([2, -2, -1]); // should not be mutated\n\n    res = sub(a1, v2, new Vector());\n    expect(res).toEqual([-1, 4, 4]);\n    expect(res).toBeInstanceOf(Vector);\n\n    // target will be overwritten and not part of the sum\n    sub(a1, v2, new Vector(10, 10, 10));\n    expect(res).toEqual([-1, 4, 4]);\n    expect(res).toBeInstanceOf(Vector);\n\n    /* multiple */\n    const vectors = [\n      vec2(1, -1),\n      vec2(3, 2),\n      vec2(-6, 0.5),\n      vec2(-3.7, 4.5),\n    ];\n\n    const arrays = [\n      [1, -1],\n      [3, 2],\n      [-6, 0.5],\n      [-3.7, 4.5],\n    ];\n\n    res = addAll(vectors, vec2());\n    expect(res).toBeInstanceOf(Vector);\n    expect(res).toEqual([-5.7, 6]);\n\n    expect(vectors[0]).toEqual([1, -1]);\n\n    // we're adding a target to avoid mutation of the first element in vectors\n    res = addAll(vectors, vec2());\n    expect(res).toEqual([-5.7, 6]);\n    expect(vectors[0]).toEqual([1, -1]);\n\n    // this will mutate the first vector in vectors\n    res = addAll(vectors);\n    expect(vectors[0]).toEqual([-5.7, 6]);\n\n    // vectors can also be plain arrays.\n    res = addAll(arrays, vec2());\n    expect(res).toBeInstanceOf(Vector);\n    expect(res).toEqual([-5.7, 6]);\n\n    // return result as plain array\n    res = addAll(arrays, [0, 0]);\n    expect(res).toBeInstanceOf(Array);\n    expect(res).toEqual([-5.7, 6]);\n\n    // or allow the first array to be mutated\n    const from = vec2(5, 5);\n    res = subAll(from, arrays);\n    expect(res).toBeInstanceOf(Array);\n    expect(res).toBe(from);\n    expect(res).toEqual([10.7, -1]);\n\n    arrays[0] = [1, -1]; // reset to original value\n\n    // subtracts all following vectors/arrays from the first parameter\n    res = subAll([10, 10], [[5, 6], [3, -1], [0, 5]]);\n    expect(res).toBeInstanceOf(Array);\n    expect(res).toEqual([2, 0]);\n\n    // we're adding a target to avoid mutation of the first element in vectors\n    res = subAll(arrays[0], arrays.slice(1), []);\n    expect(arrays[0]).toEqual([1, -1]);\n    expect(res).toEqual([7.7, -8]);\n\n    // target will NOT be part of sum when subtracting a list\n    res = subAll(vec2(5, 6), [[3, -1], [0, 5]], [100, 100]);\n    expect(res).toEqual([2, 2]);\n\n    res = subAll(vec2(5, 6), [[3, -1], [0, 5]]);\n    expect(res).toBeInstanceOf(Vector);\n    expect(res).toEqual([2, 2]);\n  });\n\n  it('can calculate the sum of squares', () => {\n    expect(sumsqr([1, 3, 4])).toBe(26);\n    expect(sumsqr(vec3(-3, -3, 2))).toBe(22);\n  });\n\n  it('can calculate the scalar of a vector/array', () => {\n    expect(scalar([1, 3, 4])).toBeCloseTo(Math.sqrt(26));\n    expect(scalar(vec3(-3, -3, 2))).toBeCloseTo(Math.sqrt(22));\n  });\n\n  it('can normalize a vector/array', () => {\n    const vector = [2, 3.4, -2];\n    const expected = [0.4522156, 0.76876657, -0.4522156];\n    let actual = norm(vector, new Vector()); // immutable\n\n    expect(actual).not.toBe(vector);\n    expect(actual).toBeInstanceOf(Vector);\n    actual.forEach((d, i) => expect(d).toBeCloseTo(expected[i]));\n\n    actual = norm(vector); // mutate vector\n\n    expect(actual).toBe(vector);\n    expect(actual).toBeInstanceOf(Array);\n    actual.forEach((d, i) => expect(d).toBeCloseTo(expected[i]));\n  });\n\n  it('can scale a vector/array by a factor', () => {\n    expect(scale([1, 2, 3], 3)).toEqual([3, 6, 9]); // mutating\n    expect(scale([1, 2, 3], -1, [])).toEqual([-1, -2, -3]); // immutable\n  });\n\n  it('should find the distance between two points', () => {\n    expect(dist([10, 0], [-10, 0])).toBe(20);\n    expect(dist(vec3(10, 2, -5), [-3, 0, 2])).toBeCloseTo(14.899664);\n  });\n\n  it('should find the directional unit vector between two points', () => {\n    expect(dir([10, 0], [-10, 0])).toEqual([-1, 0]);\n\n    let expected = [-0.872503, -0.134231, 0.469809];\n    dir(vec3(10, 2, -5), [-3, 0, 2]).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    expected = [0.707107, -0.707107];\n    dir([0, 3], [3, 0]).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    // immutable\n    dir([0, 3], [3, 0], []).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n  });\n\n  it('should describe relationships between two points', () => {\n    let res = descr([10, -3], [8, 2]);\n    expect(res.vector).toBeInstanceOf(Array);\n    expect(res.unit).toBeInstanceOf(Array);\n    expect(res.vector).toEqual([-2, 5]);\n    expect(res.sqr).toBe(29);\n    expect(res.dist).toBeCloseTo(5.3851648);\n    const expected = [-0.37139068, 0.9284767];\n    res.unit.forEach((d, i) => expect(d).toBeCloseTo(expected[i]));\n\n    res = descr([10, -3, 1], [8, 2, 0], new Vector());\n    expect(res.vector).toBeInstanceOf(Vector);\n    expect(res.unit).toBeInstanceOf(Vector);\n    expect(res.vector.x).toBe(-2);\n    expect(res.vector.y).toBe(5);\n    expect(res.vector.z).toBe(-1);\n    expect(res.sqr).toBe(30);\n    expect(res.dist).toBeCloseTo(5.4772256);\n  });\n\n  it('should find the an orthogonal unit vector', () => {\n    expect(orth2([0, 1])).toEqual([-1, 0]);\n    expect(orth2([1, 0])).toEqual([-0, 1]);\n\n    let expected = [-1 / Math.sqrt(2), 1 / Math.sqrt(2)];\n    orth2([1, 1]).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    expected = [-2 / Math.sqrt(20), 4 / Math.sqrt(20)];\n    orth2([4, 2]).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    expected = [0.049938, -0.99875];\n\n    const vector = vec([10, 2], [-10, 1]);\n    orth2(vector).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n  });\n\n  it('should be able to calculate the vector dot product', () => {\n    expect(dot([2, -2, 1], [-3.5, 1.5, -3])).toBe(-13);\n    expect(dot([1, 2, 2, 0], [3, -4, 0, -1])).toBe(-5);\n    expect(dot([0.1, 2, -1.4, 2], [2, 0.2, 2, 2.83])).toBeCloseTo(3.46, 5);\n  });\n\n  it('should be able to calculate the psudo cross product of 2d vectors', () => {\n    expect(cross2(vec2(1, 2), vec2(1, 0))).toBe(-2);\n    expect(cross2(vec2(1, 2), [-5, 2])).toBe(12);\n    expect(cross2([1, 0], vec2(0, 1))).toBe(1);\n    expect(cross2([2, 0], [1, 0])).toBe(0);\n  });\n\n  it('should be able to find the cross and triple product of 3d vectors', () => {\n    expect(cross([1, 0, 0], [0, 1, 0])).toEqual([0, 0, 1]);\n\n    const i = vec3(1, 0, 0);\n    const j = vec3(0, 1, 0);\n    const k = vec3(0, 0, 1);\n\n    const res = vec3();\n    expect(cross(i, j, res)).toEqual(k);\n    expect(cross(k, i, res)).toEqual(j);\n    expect(cross(j, k, res)).toEqual(i);\n\n    expect(triple(i, j, k)).toBe(1);\n    expect(triple(k, i, j)).toBe(k.dot(i.cross(j)));\n  });\n\n  it('Can find angles of 2d vectors', () => {\n    expect(angle2(vec2(1, 0))).toBe(0);\n    expect(angle2(vec2(1, 1))).toBe(Math.PI / 4);\n    expect(angle2(vec2(0, 1))).toBe(Math.PI / 2);\n    expect(angle2(vec2(-1, 0))).toBe(Math.PI);\n    expect(angle2(vec2(-1, -1))).toBe(-0.75 * Math.PI);\n    expect(angle2(vec2(0, -1))).toBe(-0.5 * Math.PI);\n    expect(angle2(vec2(0, 0))).toBe(0);\n  });\n\n  it('Can find angles of 3d vectors', () => {\n    const v = new Vector(2, 1, 2, 0);\n\n    expect(angle(v)).toBe(angle(v, 0));\n    expect(angle(v)).toBeCloseTo(0.841069, 5);\n    expect(angle(v, 1)).toBeCloseTo(1.23096, 5);\n    expect(angle(v, 2)).toBeCloseTo(0.84107, 5);\n    expect(angle(v, 3)).toBeUndefined();\n    expect(angle(v, -1)).toBeUndefined();\n  });\n\n  it('should be able to clamp values and vectors/arrays', () => {\n    expect(clamp(-1, 0, 1)).toBe(0);\n    expect(clamp(2, 0, 1)).toBe(1);\n    expect(clamp(2, 0, 3)).toBe(2);\n\n    expect(clamp([0.32, 6.2, 3.7], 0.4, 5.8)).toEqual([0.4, 5.8, 3.7]);\n    expect(clamp(vec3(0.32, 6.2, 3.7), 0.2, 6)).toEqual([0.32, 6, 3.7]);\n\n    const v1 = vec4(1, 2, 3, 4);\n    const v2 = vec4(6, -4, 0, 2);\n\n    expect(clamp(v1, 1.25, 3.5)).toEqual(vec4(1.25, 2, 3, 3.5));\n    expect(clamp(v2, 1.25, 3.5)).toEqual(vec4(3.5, 1.25, 1.25, 2));\n    expect(clamp(\n      [\n        1, 2, 3,\n        4, 5, 6,\n        7, 8, 9,\n      ],\n      2.5,\n      8.2,\n    )).toEqual([\n      2.5, 2.5, 3,\n      4, 5, 6,\n      7, 8, 8.2,\n    ]);\n    expect(clamp(-1)).toBe(0);\n    expect(clamp(-1, 1)).toBe(1);\n    expect(clamp(1.25)).toBe(1);\n    expect(clamp(1.25, 0, 0.9)).toBe(0.9);\n  });\n\n  it('Can generate threshold values with step and smoothstep functions (as in GLSL)', () => {\n    expect(step(0.5, 0.4)).toBe(0);\n    expect(step(0.5, 0.5)).toBe(1);\n    expect(step(0.5, 0.6)).toBe(1);\n\n    expect(step(vec3(1, 0.5, 2), vec3(2, 0.2, 1))).toEqual(vec3(1, 0, 0));\n\n    expect(smoothstep(0.2, 0.6, 0.1)).toBe(0);\n    expect(smoothstep(0.2, 0.6, 0.2)).toBe(0);\n    expect(smoothstep(0.2, 0.6, 0.21)).toBeGreaterThan(0);\n    expect(smoothstep(0.2, 0.6, 0.4)).toBeCloseTo(0.5);\n    expect(smoothstep(0.2, 0.6, 0.6)).toBe(1);\n    expect(smoothstep(0.2, 0.6, 0.7)).toBe(1);\n  });\n\n  it('Can mix vectors, matrices and values', () => {\n    // mix works on arrays, meaning also vectors and matrices\n    const v1 = vec4(1, 2, 3, 4);\n    const v2 = vec4(6, -4, 0, 2);\n    const res = new Vector(4);\n    expect(mix(v1, v2, 0, res)).toEqual(v1);\n    expect(mix(v1, v2, 1, res)).toEqual(v2);\n    expect(mix(v1, v2, 0.25, res)).toEqual(vec4(2.25, 0.5, 2.25, 3.5));\n    expect(mix(v1, v2, 0.5, res)).toEqual(vec4(3.5, -1, 1.5, 3));\n    expect(mix(v1, v2, 0.75, res)).toEqual(vec4(4.75, -2.5, 0.75, 2.5));\n    expect(mix(v1, v2, vec4(0, 0.25, 0.5, 0.75), res)).toEqual(vec4(1, 0.5, 1.5, 2.5));\n\n    const m = mat2(-7, 2, 0, 2);\n    expect(mix(m, Matrix.identity(2), 0.5)).toEqual(mat2(-3, 1, 0, 1.5));\n\n    // lerp is for mixing primitive numbers\n    expect(lerp(10, 20, 0.5)).toBe(15);\n  });\n\n  it('Can round vectors and values', () => {\n    expect(round(1.2253455, 2)).toBe(1.23);\n    expect(round(1.2253455, 1)).toBe(1.2);\n    expect(round(1.2253455, 6)).toBe(1.225346);\n    const v = vec4(1.12345, 2.23321, 3.321, 4.033);\n    expect(round(v, 1)).toEqual(vec4(1.1, 2.2, 3.3, 4));\n  });\n\n  it('Can convert between degrees and radians', () => {\n    expect(deg(0)).toBe(0);\n    expect(deg(PI)).toBe(180);\n    expect(deg(-PI)).toBe(-180);\n    expect(deg(SPI)).toBe(90);\n    expect(deg(-SPI)).toBe(-90);\n    expect(deg(QPI)).toBe(45);\n    expect(deg(-QPI)).toBe(-45);\n    expect(deg(TAU)).toBe(360);\n    expect(deg(-TAU)).toBe(-360);\n\n    expect(rad(0)).toBe(0);\n    expect(rad(180)).toBe(PI);\n    expect(rad(-180)).toBe(-PI);\n    expect(rad(90)).toBe(SPI);\n    expect(rad(-90)).toBe(-SPI);\n    expect(rad(45)).toBe(QPI);\n    expect(rad(-45)).toBe(-QPI);\n    expect(rad(360)).toBe(TAU);\n    expect(rad(-360)).toBe(-TAU);\n\n    expect(nrad(-QPI)).toBe(TAU - QPI);\n    expect(nrad(-SPI)).toBe(TAU - SPI);\n    expect(nrad(-TAU)).toBe(-0);\n    expect(nrad(-TAU - SPI)).toBe(TAU - SPI);\n  });\n\n  it('can create a sequence of interpolated values', () => {\n    let a = 100;\n    let b = 450;\n\n    let expected = [100, 450];\n\n    seq(a, b, 2).forEach((v, i) => expect(v).toBe(expected[i]));\n\n    expected = [100, 150, 200, 250, 300, 350, 400, 450];\n    seq(a, b, 8).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    // start at t=0.5 to t=0.75, same amount of steps\n    expected = [275, 287.5, 300, 312.5, 325, 337.5, 350, 362.5];\n    seq(a, b, 8, 0.5, 0.75).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    a = 0;\n    b = 1;\n    expected = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\n    seq(a, b, 11).forEach((v, i) => expect(v).toBeCloseTo(expected[i]));\n\n    // array\n    a = [0, 0, 0];\n    b = [10, -20, 100];\n    expected = [\n      [0, 0, 0],\n      [2.5, -5, 25],\n      [5, -10, 50],\n      [7.5, -15, 75],\n      [10, -20, 100],\n    ];\n    seq(a, b, 5).forEach((v, i) => expect(v).toEqual(expected[i]));\n\n    expected = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\n    // optimized for 0..1 sequences\n    seqI(11).forEach((v, i) => expect(v).toBeCloseTo(expected[i], 10));\n\n  });\n\n  it('should allow easy check for null vectors', () => {\n    expect(isNullVec([0, 0, 0])).toBeTruthy();\n    expect(isNullVec([-0, -0, -0])).toBeTruthy();\n    expect(isNullVec([-1, -2, -3])).toBeFalsy();\n    expect(isNullVec([0.00001, 0, 0])).toBeFalsy();\n    expect(isNullVec([-0.00001, -0, -0], 0.001)).toBeTruthy();\n  });\n});\n\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/test/functions.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 165,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/functions.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functions.spec.js~describe0",
    "access": null,
    "description": "functions.js",
    "lineNumber": 41
  },
  {
    "__docId__": 166,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it1",
    "access": null,
    "description": "should be able to create a vector from two points",
    "lineNumber": 42
  },
  {
    "__docId__": 167,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it2",
    "access": null,
    "description": "should be able to add and subtract vectors/arrays",
    "lineNumber": 55
  },
  {
    "__docId__": 168,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it3",
    "access": null,
    "description": "can calculate the sum of squares",
    "lineNumber": 181
  },
  {
    "__docId__": 169,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it4",
    "access": null,
    "description": "can calculate the scalar of a vector/array",
    "lineNumber": 186
  },
  {
    "__docId__": 170,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it5",
    "access": null,
    "description": "can normalize a vector/array",
    "lineNumber": 191
  },
  {
    "__docId__": 171,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it6",
    "access": null,
    "description": "can scale a vector/array by a factor",
    "lineNumber": 207
  },
  {
    "__docId__": 172,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it7",
    "access": null,
    "description": "should find the distance between two points",
    "lineNumber": 212
  },
  {
    "__docId__": 173,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it8",
    "access": null,
    "description": "should find the directional unit vector between two points",
    "lineNumber": 217
  },
  {
    "__docId__": 174,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it9",
    "access": null,
    "description": "should describe relationships between two points",
    "lineNumber": 230
  },
  {
    "__docId__": 175,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it10",
    "access": null,
    "description": "should find the an orthogonal unit vector",
    "lineNumber": 250
  },
  {
    "__docId__": 176,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it11",
    "access": null,
    "description": "should be able to calculate the vector dot product",
    "lineNumber": 266
  },
  {
    "__docId__": 177,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it12",
    "access": null,
    "description": "should be able to calculate the psudo cross product of 2d vectors",
    "lineNumber": 272
  },
  {
    "__docId__": 178,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it13",
    "access": null,
    "description": "should be able to find the cross and triple product of 3d vectors",
    "lineNumber": 279
  },
  {
    "__docId__": 179,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it14",
    "access": null,
    "description": "Can find angles of 2d vectors",
    "lineNumber": 295
  },
  {
    "__docId__": 180,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it15",
    "access": null,
    "description": "Can find angles of 3d vectors",
    "lineNumber": 305
  },
  {
    "__docId__": 181,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it16",
    "access": null,
    "description": "should be able to clamp values and vectors/arrays",
    "lineNumber": 316
  },
  {
    "__docId__": 182,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it17",
    "access": null,
    "description": "Can generate threshold values with step and smoothstep functions (as in GLSL)",
    "lineNumber": 348
  },
  {
    "__docId__": 183,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it18",
    "access": null,
    "description": "Can mix vectors, matrices and values",
    "lineNumber": 363
  },
  {
    "__docId__": 184,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it19",
    "access": null,
    "description": "Can round vectors and values",
    "lineNumber": 382
  },
  {
    "__docId__": 185,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it20",
    "access": null,
    "description": "Can convert between degrees and radians",
    "lineNumber": 390
  },
  {
    "__docId__": 186,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it21",
    "access": null,
    "description": "can create a sequence of interpolated values",
    "lineNumber": 417
  },
  {
    "__docId__": 187,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "test/functions.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functions.spec.js~describe0.it22",
    "access": null,
    "description": "should allow easy check for null vectors",
    "lineNumber": 455
  },
  {
    "__docId__": 188,
    "kind": "testFile",
    "name": "test/matrix.spec.js",
    "content": "/* eslint-disable comma-spacing */\nimport expect from 'expect';\nimport { Matrix, mat2, mat3, mat4 } from '../src/matrix';\nimport { Vector } from '../src/vector';\n\n\ndescribe('matrix.js', () => {\n  it('should be possible to instantiate and assign values using factory functions', () => {\n    expect(new Matrix().length).toBe(16);\n    expect(new Matrix(2).length).toBe(4);\n    expect(new Matrix(3).length).toBe(9);\n    expect(new Matrix(4).length).toBe(16);\n\n    let m = new Matrix(4, 2);\n    expect(m.length).toBe(8);\n    expect(m.columns).toBe(2);\n    expect(m.rows).toBe(4);\n    expect(m.isSquare).toBeFalsy();\n\n    m.copyFrom([\n      1, 2,\n      3, 4,\n      5, 6,\n      7, 8,\n    ]);\n\n    expect(m.toArray()).toEqual([1, 3, 5, 7, 2, 4, 6, 8]);\n\n    m = new Matrix(2, 2, [1, 0, 0, 1]);\n\n    expect(m).toEqual(Matrix.identity(2));\n\n    expect(mat2(1, 2, 3, 4, 5, 6, 7).toArray()).toEqual([1, 3, 2, 4]);\n\n    m = mat4(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);\n    expect(m.length).toBe(16);\n    expect(m.rows).toBe(4);\n    expect(m.columns).toBe(4);\n\n    expect(m.toArray()).toEqual([1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16]);\n\n    // values should be stored internally in columns-first order\n    // elements can be accessed (up to 4d) using the property\n    // syntax: a{row}{column}\n    expect(m.a11).toBe(m[0]);\n    expect(m.a21).toBe(m[1]);\n    expect(m.a31).toBe(m[2]);\n    expect(m.a41).toBe(m[3]);\n    expect(m.a12).toBe(m[4]);\n    expect(m.a22).toBe(m[5]);\n    expect(m.a32).toBe(m[6]);\n    expect(m.a42).toBe(m[7]);\n    expect(m.a13).toBe(m[8]);\n    expect(m.a23).toBe(m[9]);\n    expect(m.a33).toBe(m[10]);\n    expect(m.a43).toBe(m[11]);\n    expect(m.a14).toBe(m[12]);\n    expect(m.a24).toBe(m[13]);\n    expect(m.a34).toBe(m[14]);\n    expect(m.a44).toBe(m[15]);\n\n    // assign new value to row 3 column 2\n    m.a32 = 20;\n    expect(m[6]).toBe(20);\n    // asign new value to row 2 column 3\n    m[9] = 14;\n    expect(m.a23).toBe(14);\n  });\n\n  it('should be possible to instantiate matrices from existing arrays', () => {\n    // identity matrix\n    const I = Matrix.identity(3);\n\n    expect(I.isSquare).toBeTruthy();\n    expect(I.toArray()).toEqual([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n\n    // from existing array\n    const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    expect(Matrix.fromArray(arr, 2).toArray2d(true)).toEqual([\n      [1, 2],\n      [3, 4],\n      [5, 6],\n      [7, 8],\n    ]);\n\n    expect(Matrix.fromArray(arr, 3).toArray2d(true)).toEqual([\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9],\n    ]);\n\n    // mutates input arr by reducing its size to fit the matrix\n    expect(Matrix.fromArray(arr, 4, true, true).toArray2d(true)).toEqual([\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n    ]);\n    expect(arr.length).toBe(8);\n  });\n\n  it('should be possible to instantiate matrices from vectors', () => {\n    const i = [1, 0, 0.5];\n    const j = [0, 1, 0];\n    const k = [0, 0, 1];\n\n    expect(Matrix.fromVectors(i, j, k).toArray(true)).toEqual([\n      1, 0, 0,\n      0, 1, 0,\n      0.5, 0, 1,\n    ]);\n  });\n\n  it('should be able to extract values or subsets of values', () => {\n    const m = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n    // columns first (as stored internally)\n    const columnsFirst = m.toArray();\n    expect(columnsFirst).toEqual([1, 4, 7, 2, 5, 8, 3, 6, 9]);\n    expect(columnsFirst).not.toBe(m);\n    expect(m.columnsFirst()).toEqual(columnsFirst);\n\n    // rows first\n    const rowsFirst = m.toArray(true);\n    expect(rowsFirst).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    expect(rowsFirst).not.toBeInstanceOf(Matrix);\n    expect(m.rowsFirst()).toEqual(rowsFirst);\n\n    /* Transform to 2d array */\n\n    // columns first\n    expect(m.toArray2d()).toEqual([[1, 4, 7], [2, 5, 8], [3, 6, 9]]);\n    // rows first\n    expect(m.toArray2d(true)).toEqual([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n    /* Columns and rows */\n    expect(m.col(0)).toEqual([1, 4, 7]);\n    expect(m.col(1)).toEqual([2, 5, 8]);\n    expect(m.col(2)).toEqual([3, 6, 9]);\n\n    expect(m.row(0)).toEqual([1, 2, 3]);\n    expect(m.row(1)).toEqual([4, 5, 6]);\n    expect(m.row(2)).toEqual([7, 8, 9]);\n\n    /* sub-matrix */\n    let sm = m.submatrix(1, 0, 2, 1);\n    expect(sm.rows).toBe(2);\n    expect(sm.columns).toBe(1);\n    expect(sm.toArray(true)).toEqual([4, 7]);\n\n    sm = m.submatrix(1, 1, 2, 2, new Matrix(2, 2));\n    expect(sm.rows).toBe(2);\n    expect(sm.columns).toBe(2);\n    expect(sm.toArray(true)).toEqual([5, 6, 8, 9]);\n  });\n\n  it('should be possible to transpose a matrix', () => {\n    let m = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n    let transposed = m.transpose();\n    expect(m).toBe(transposed);\n    expect(m.toArray()).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n    // immutable\n    transposed = m.transpose(new Matrix());\n    expect(m).not.toBe(transposed);\n    expect(m.toArray()).not.toEqual(transposed.toArray());\n\n    m = new Matrix(3, 2, [\n      1, 2,\n      3, 4,\n      5, 6,\n    ]);\n\n    expect(m.rows).toBe(3);\n    expect(m.columns).toBe(2);\n\n    transposed = m.transpose(new Matrix());\n    expect(transposed.rows).toBe(2);\n    expect(transposed.columns).toBe(3);\n    expect(transposed.toArray2d(true)).toEqual([ // rows first\n      [1, 3, 5],\n      [2, 4, 6],\n    ]);\n\n  });\n\n  it('should be possible to remove rows/colums from a matrix', () => {\n    let m = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    m.remove(1);\n    expect(m.rows).toBe(2);\n    expect(m.columns).toBe(3);\n    expect(m.toArray(true)).toEqual([\n      1, 2, 3,\n      7, 8, 9,\n    ]);\n\n    m = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    m.remove(null, 1);\n    expect(m.rows).toBe(3);\n    expect(m.columns).toBe(2);\n    expect(m.toArray(true)).toEqual([\n      1, 3,\n      4, 6,\n      7, 9,\n    ]);\n\n    m = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n    m.remove(2, 1);\n    expect(m.rows).toBe(2);\n    expect(m.columns).toBe(2);\n    expect(m.toArray(true)).toEqual([\n      1, 3,\n      4, 6,\n    ]);\n\n    // immutable\n    m = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    const m2 = m.remove(1, 1, new Matrix());\n    expect(m.rows).toBe(3);\n    expect(m.columns).toBe(3);\n    expect(m2.rows).toBe(2);\n    expect(m2.columns).toBe(2);\n    expect(m2.toArray(true)).toEqual([\n      1, 3,\n      7, 9,\n    ]);\n  });\n\n  it('should be possible to calculate the product between two matrices as well as matrix and vector/array', () => {\n    const S = mat3(\n      2, 0, 0,\n      0, 2, 0,\n      0, 0, 1,\n    );\n\n    const T = mat3(\n      1, 0, 2,\n      0, 1,-3,\n      0, 0, 1,\n    );\n\n    let v = new Vector(2, -1.5);\n\n    const a = S.dot(T, mat3());\n    const b = S.dot(v, new Vector(2));\n    const c = S.dot([-3, 2]);\n\n    expect(a).toBeInstanceOf(Matrix);\n    expect(a.rowsFirst()).toEqual([\n      2, 0, 4,\n      0, 2, -6,\n      0, 0, 1,\n    ]);\n\n    expect(b).toBeInstanceOf(Vector);\n    expect(b).toEqual([4, -3]);\n\n    expect(c).toBeInstanceOf(Array);\n    expect(c).toEqual([-6, 4]);\n\n    const M = mat4(\n      1, 0, 0, -4,\n      0, 1, 0, 2,\n      0, 0, 1, 1,\n      0, 0, 0, 1,\n    );\n    v = new Vector(-250, -250, 1);\n\n    // mutates input array\n    expect(M.dot([-250, -250, 1, 1])).toEqual([-254, -248, 2, 1]);\n\n    // To allow affine transformations supporting translations\n    // you need to use 4d matrices in 3d space and 3d matrices\n    // in 2d space etc. This lib will treat any vector as\n    // if it had the same number of components as the matrix has\n    // rows, i.e. it fills in the blanks or truncate its size.\n\n    // immutable: M4 * V3 = V4\n    expect(M.dot(v, new Vector(4))).toEqual([-254, -248, 2, 1]);\n\n    // immutable: M4 * V3 = V3\n    expect(M.dot(v, new Vector(3))).toEqual([-254, -248, 2]);\n\n    // mutable: M4 * V3 = V3\n    expect(M.dot(v)).toEqual([-254, -248, 2]);\n  });\n\n  it('should be able to find the inverse of a (square) matrix', () => {\n    expect(() => new Matrix(3, 2).inverse()).toThrow();\n    expect(() => Matrix.identity().inverse()).not.toThrow();\n    expect(Matrix.identity(4).inverse()).toEqual(Matrix.identity(4));\n\n    let actual = mat2(3, 3.5, 3.2, 3.6).inverse();\n    let expected = [-9, 8.75, 8, -7.5];\n    actual.every((a, i) => expect(a).toBeCloseTo(expected[i], 5));\n\n    actual = mat2(4, 7, 2, 6).inverse();\n    expected = [0.6, -0.7, -0.2, 0.4];\n    actual.every((a, i) => expect(a).toBeCloseTo(expected[i], 5));\n\n    // imutable\n    const m = mat4(\n      2, 0, 0, 0,\n      0, 1.5, 0, 0,\n      0, 0, 3, 0,\n      0, 0, 0, 1,\n    );\n    actual = m.inverse(new Matrix());\n    expect(m).not.toBe(actual);\n    expect(m.toArray(true)).toEqual([\n      2, 0, 0, 0,\n      0, 1.5, 0, 0,\n      0, 0, 3, 0,\n      0, 0, 0, 1,\n    ]);\n    expected = [0.5, 0, 0, 0, 0, 0.666667, 0, 0, 0, 0, 0.333333, 0, 0, 0, 0, 1];\n    actual.every((a, i) => expect(a).toBeCloseTo(expected[i], 5));\n\n    expect(mat2(0, -1, 2, 4).inverse().toArray(true)).toEqual([2, 0.5, -1, -0]);\n  });\n\n  it('should be able to calculate its determinant', () => {\n    expect(() => new Matrix(3, 2).determinant()).toThrow();\n    expect(Matrix.identity().determinant()).toBe(1);\n    expect(mat2(1, 3, 2, -1).determinant()).toBe(-7);\n    expect(mat3(-2, 2, 3, -1, 1, 3, 2, 0, -1).determinant()).toBe(6);\n    expect(mat4(1, 3, 5, 9, 1, 3, 1, 7, 4, 3, 9, 7, 5, 2, 0, 9).determinant()).toBe(-376);\n    expect(mat4(\n      1, 2, 3, -4,\n      -5, -6, 7, 8,\n      9, 10, 11, 12,\n      -13, 14, 15, 16,\n    ).determinant()).toBe(25344);\n  });\n});\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/test/matrix.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 189,
    "kind": "test",
    "name": "describe23",
    "testId": 23,
    "memberof": "test/matrix.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/matrix.spec.js~describe23",
    "access": null,
    "description": "matrix.js",
    "lineNumber": 7
  },
  {
    "__docId__": 190,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it24",
    "access": null,
    "description": "should be possible to instantiate and assign values using factory functions",
    "lineNumber": 8
  },
  {
    "__docId__": 191,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it25",
    "access": null,
    "description": "should be possible to instantiate matrices from existing arrays",
    "lineNumber": 70
  },
  {
    "__docId__": 192,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it26",
    "access": null,
    "description": "should be possible to instantiate matrices from vectors",
    "lineNumber": 100
  },
  {
    "__docId__": 193,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it27",
    "access": null,
    "description": "should be able to extract values or subsets of values",
    "lineNumber": 112
  },
  {
    "__docId__": 194,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it28",
    "access": null,
    "description": "should be possible to transpose a matrix",
    "lineNumber": 155
  },
  {
    "__docId__": 195,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it29",
    "access": null,
    "description": "should be possible to remove rows/colums from a matrix",
    "lineNumber": 186
  },
  {
    "__docId__": 196,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it30",
    "access": null,
    "description": "should be possible to calculate the product between two matrices as well as matrix and vector/array",
    "lineNumber": 229
  },
  {
    "__docId__": 197,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it31",
    "access": null,
    "description": "should be able to find the inverse of a (square) matrix",
    "lineNumber": 288
  },
  {
    "__docId__": 198,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "test/matrix.spec.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/matrix.spec.js~describe23.it32",
    "access": null,
    "description": "should be able to calculate its determinant",
    "lineNumber": 322
  },
  {
    "__docId__": 199,
    "kind": "testFile",
    "name": "test/use-cases.spec.js",
    "content": "import expect from 'expect';\nimport { Matrix } from '../src/matrix';\nimport { vec2, vec3, Vector } from '../src/vector';\n\ndescribe('some example use cases', () => {\n  it('Can transform from one dimension to another', () => {\n    // 3d to 2d\n    let m = new Matrix(2, 3, [\n      2, 0, 0,\n      0, 3, 0,\n    ]);\n    let v = vec3(2, -2, 4);\n\n    let t = m.dot(v);\n    expect(t.length).toBe(2);\n    expect(t).toEqual([4, -6]);\n\n    // 3d to 1d\n    m = new Matrix(1, 3, [2, 0, 0]);\n    v = vec3(2, -2, 4);\n\n    t = m.dot(v);\n    expect(t).toEqual([4]);\n\n    // 2d to 3d\n    m = new Matrix(3, 2, [\n      1, 0,\n      0, 1,\n      1, 1,\n    ]);\n\n    v = vec2(2, -5);\n\n    t = m.dot(v, new Vector(3));\n    expect(t.length).toBe(3);\n    expect(t).toEqual([2, -5, -3]);\n  });\n});\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/test/use-cases.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 200,
    "kind": "test",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/use-cases.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/use-cases.spec.js~describe33",
    "access": null,
    "description": "some example use cases",
    "lineNumber": 5
  },
  {
    "__docId__": 201,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "test/use-cases.spec.js~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "test/use-cases.spec.js~describe33.it34",
    "access": null,
    "description": "Can transform from one dimension to another",
    "lineNumber": 6
  },
  {
    "__docId__": 202,
    "kind": "testFile",
    "name": "test/utils.spec.js",
    "content": "import expect from 'expect';\nimport {\n  flattenList,\n  rowsToColumns,\n} from '../src/utils';\nimport { vec2, vec3, vec4 } from '../src/vector';\n\ndescribe('utils.js', () => {\n  it('should be able to transpose rows to columns where 2d data are stored in 1d arrays', () => {\n    expect(rowsToColumns([1, 2, 3, 4, 5, 6], 2)).toEqual([1, 3, 5, 2, 4, 6]);\n    expect(rowsToColumns([1, 7, 2, 8, 3, 9], 2)).toEqual([1, 2, 3, 7, 8, 9]);\n  });\n\n  it('should be able to flatten a list, that may contain nested arrays, of arguments into a 1d array', () => {\n    expect(flattenList([1, [2, [3], 4], [5, 6]])).toEqual([1, 2, 3, 4, 5, 6]);\n    expect(flattenList([1, [2, [3], 4], [5, 6]], [], 4)).toEqual([1, 2, 3, 4]);\n    expect(flattenList(vec4(vec3(vec2(1, 2), 3), 4))).toEqual([1, 2, 3, 4]);\n  });\n});\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/test/utils.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 203,
    "kind": "test",
    "name": "describe35",
    "testId": 35,
    "memberof": "test/utils.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/utils.spec.js~describe35",
    "access": null,
    "description": "utils.js",
    "lineNumber": 8
  },
  {
    "__docId__": 204,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "test/utils.spec.js~describe35",
    "testDepth": 1,
    "static": true,
    "longname": "test/utils.spec.js~describe35.it36",
    "access": null,
    "description": "should be able to transpose rows to columns where 2d data are stored in 1d arrays",
    "lineNumber": 9
  },
  {
    "__docId__": 205,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/utils.spec.js~describe35",
    "testDepth": 1,
    "static": true,
    "longname": "test/utils.spec.js~describe35.it37",
    "access": null,
    "description": "should be able to flatten a list, that may contain nested arrays, of arguments into a 1d array",
    "lineNumber": 14
  },
  {
    "__docId__": 206,
    "kind": "testFile",
    "name": "test/vector.spec.js",
    "content": "import expect from 'expect';\nimport { Vector, nvec, vec2, vec3, vec4 } from '../src/vector';\n\n\ndescribe('vector.js', () => {\n  it('should be possible to instantiate and assign values using factory functions', () => {\n    expect(vec3()).toEqual([0, 0, 0]);\n    expect(vec4(1)).toEqual([1, 1, 1, 1]);\n    expect(vec3(vec2(1, 2), 3)).toEqual([1, 2, 3]);\n    expect(nvec(10)).toEqual([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    const vectorFromArray = Vector.fromArray([1, 2, 3, 4]);\n    expect(vectorFromArray).toEqual([1, 2, 3, 4]);\n    expect(vectorFromArray).toBeInstanceOf(Vector);\n    expect(vectorFromArray).toBeInstanceOf(Array);\n    expect(new Vector(4)).toEqual(new Array(4));\n  });\n\n  it('should be able to use array getters/setters and extended/added vector getter/setters', () => {\n    const v = vec4(1, 2, 3, 4);\n\n    expect(v[0]).toBe(1);\n    expect(v[1]).toBe(2);\n    expect(v[2]).toBe(3);\n    expect(v[3]).toBe(4);\n\n    expect(v.length).toBe(4);\n\n    // coordinates\n    expect(v.x).toBe(v[0]);\n    expect(v.y).toBe(v[1]);\n    expect(v.z).toBe(v[2]);\n    expect(v.w).toBe(v[3]);\n\n    // rgba\n    expect(v.r).toBe(v[0]);\n    expect(v.g).toBe(v[1]);\n    expect(v.b).toBe(v[2]);\n    expect(v.a).toBe(v[3]);\n\n    // ijkl\n    expect(v.i).toBe(v[0]);\n    expect(v.j).toBe(v[1]);\n    expect(v.k).toBe(v[2]);\n    expect(v.l).toBe(v[3]);\n\n    // stuv\n    expect(v.s).toBe(v[0]);\n    expect(v.t).toBe(v[1]);\n    expect(v.u).toBe(v[2]);\n    expect(v.v).toBe(v[3]);\n\n    v[1] = 6;\n    expect(v.y).toBe(6);\n\n    // \"swizzle\"\n    const swizzled = v.swizzle('xxzy');\n    expect(swizzled).toEqual([1, 1, 3, 6]);\n  });\n\n  it('should be possible to clone vector', () => {\n    const v = vec2(-3, 2);\n    const clone = v.clone();\n    expect(clone).toEqual(v);\n    expect(clone).not.toBe(v);\n    v.x = 0;\n    expect(v).toEqual([0, 2]);\n    expect(clone).toEqual([-3, 2]);\n  });\n\n  it('should be mappable to float32 array', () => {\n    const v = vec4(1.002, 2.3245, -3.6612, 4.3);\n    const f = new Float32Array(v);\n    expect(f).toBeInstanceOf(Float32Array);\n    expect(f[0]).toBeCloseTo(1.002);\n    expect(f[1]).toBeCloseTo(2.3245);\n    expect(f[2]).toBeCloseTo(-3.6612);\n    expect(f[3]).toBeCloseTo(4.3);\n  });\n\n  it('should be possible to add/subtract two vectors', () => {\n    const v1 = vec2(-3, 2);\n    const v2 = vec2(3, -7);\n    expect(v1.add(v2)).toEqual([0, -5]);\n    expect(v1).toEqual([0, -5]);\n\n    v1.set(-3, 2);\n\n    expect(v2.sub(v1)).toEqual([6, -9]);\n  });\n\n  it('should be possible to add/subtract a scaled version of a vector', () => {\n    const v1 = vec2(-3, 2);\n    const v2 = vec2(3, -7);\n    expect(v1.add(v2)).toEqual([0, -5]);\n    expect(v1).toEqual([0, -5]);\n\n    v1.set(-3, 2);\n\n    expect(v2.sub(v1)).toEqual([6, -9]);\n\n    v2.set(3, -7);\n\n    expect(v1.addScaled(v2, 0.5)).toEqual([-1.5, -1.5]);\n\n    v1.set(-3, 2);\n\n    expect(v1.subScaled(v2, 0.5)).toEqual([-4.5, 5.5]);\n\n  });\n\n  it('should be possible to add/subtract multiple vectors', () => {\n    const vectors = [\n      vec2(1, 4),\n      vec2(-2, 0),\n      vec2(7, -3),\n    ];\n\n    const v1 = vec2(-3, 2);\n    expect(v1.add(...vectors)).toEqual([3, 3]);\n\n    const v2 = vec2(-3, 2);\n    expect(v2.sub(...vectors)).toEqual([-9, 1]);\n  });\n\n  it('should calculate the vector scalar (length)', () => {\n    const v = vec2(-3, 2);\n    expect(v.scalar()).toBeCloseTo(Math.sqrt(13));\n  });\n\n  it('should be able to scale vector', () => {\n    const v = vec2(-3, 2);\n    expect(v.scale(2)).toEqual([-6, 4]);\n  });\n\n  it('should be able to negate a vector', () => {\n    const v = vec2(-3, 2);\n    expect(v.negate()).toEqual([3, -2]);\n  });\n\n  it('should be able to calculate the psudo cross product of two 2d vectors', () => {\n    const v = vec2(-3, 2);\n    expect(v.cross2([1, 1])).toBe(-5);\n  });\n\n  it('should be able to calculate the distance between two vectors', () => {\n    const v1 = vec2(-3, 2);\n    const v2 = vec2(3, -7);\n    expect(v1.distance(v2)).toBeCloseTo(10.8166538);\n  });\n});\n",
    "static": true,
    "longname": "/Users/kjerandp/Projects/copy/linear-algebra/test/vector.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 207,
    "kind": "test",
    "name": "describe38",
    "testId": 38,
    "memberof": "test/vector.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/vector.spec.js~describe38",
    "access": null,
    "description": "vector.js",
    "lineNumber": 5
  },
  {
    "__docId__": 208,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it39",
    "access": null,
    "description": "should be possible to instantiate and assign values using factory functions",
    "lineNumber": 6
  },
  {
    "__docId__": 209,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it40",
    "access": null,
    "description": "should be able to use array getters/setters and extended/added vector getter/setters",
    "lineNumber": 18
  },
  {
    "__docId__": 210,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it41",
    "access": null,
    "description": "should be possible to clone vector",
    "lineNumber": 60
  },
  {
    "__docId__": 211,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it42",
    "access": null,
    "description": "should be mappable to float32 array",
    "lineNumber": 70
  },
  {
    "__docId__": 212,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it43",
    "access": null,
    "description": "should be possible to add/subtract two vectors",
    "lineNumber": 80
  },
  {
    "__docId__": 213,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it44",
    "access": null,
    "description": "should be possible to add/subtract a scaled version of a vector",
    "lineNumber": 91
  },
  {
    "__docId__": 214,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it45",
    "access": null,
    "description": "should be possible to add/subtract multiple vectors",
    "lineNumber": 111
  },
  {
    "__docId__": 215,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it46",
    "access": null,
    "description": "should calculate the vector scalar (length)",
    "lineNumber": 125
  },
  {
    "__docId__": 216,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it47",
    "access": null,
    "description": "should be able to scale vector",
    "lineNumber": 130
  },
  {
    "__docId__": 217,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it48",
    "access": null,
    "description": "should be able to negate a vector",
    "lineNumber": 135
  },
  {
    "__docId__": 218,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it49",
    "access": null,
    "description": "should be able to calculate the psudo cross product of two 2d vectors",
    "lineNumber": 140
  },
  {
    "__docId__": 219,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "test/vector.spec.js~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/vector.spec.js~describe38.it50",
    "access": null,
    "description": "should be able to calculate the distance between two vectors",
    "lineNumber": 145
  }
]